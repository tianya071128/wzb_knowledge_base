# git revert

## 作用

用于**安全撤销特定提交（commit）的修改**的命令。它的核心逻辑是：**创建一个新的提交，该提交的内容与目标提交的修改完全相反**，从而抵消目标提交的影响，同时保留原提交的历史记录（不删除或改写历史）。

- **不删除历史**：`git revert` 不会删除目标提交，而是通过新提交 “抵消” 其影响，原提交仍保留在历史中（可通过 `git log` 查看），确保历史可追溯。
- **安全协作**：对于多人共享的分支（如 `main`），使用 `revert` 撤销提交不会改写已被他人拉取的历史，避免团队成员的本地仓库出现历史不一致。
- **精确撤销**：可以针对单个提交、多个连续提交进行撤销，甚至处理合并提交（需特殊参数）。

## 概述

```bash
git revert [--[no-]edit] [-n] [-m <父提交数量>] [-s] [-S[<键 ID>]] <提交>…
git revert (--continue | --skip | --abort | --quit)
```

## 基本原理

**Revert 的本质**：不是删除历史提交，而是创建一个**反向补丁**来抵消目标提交的更改，从而安全地撤销更改而不重写历史。

```text
1. 分析目标提交 → 2. 计算反向差异 → 3. 应用反向补丁 → 4. 解决冲突 → 5. 创建新提交
```

1. **步骤 1：提交分析**

   ```bash
   # Git 分析目标提交的元数据和更改
   git cat-file -p target-commit
   # 获取 tree、parent、author、committer、message
   
   git diff-tree -p parent-commit target-commit
   # 获取目标提交引入的具体更改
   ```

2. **步骤 2：**反向补丁生成

   对于目标提交的每个更改，Git 生成对应的反向操作：

   | **原操作** | **反向操作** |
   | :--------- | :----------- |
   | 添加行     | 删除行       |
   | 删除行     | 添加行       |
   | 修改行     | 恢复为原内容 |
   | 添加文件   | 删除文件     |
   | 删除文件   | 恢复文件     |

   ```bash
   # Git 计算反向补丁
   # 如果原提交添加了内容：
   # 原差异: +This is new line
   # 反向差异: -This is new line
   
   # 如果原提交删除了内容：
   # 原差异: -This is deleted line  
   # 反向差异: +This is deleted line
   ```

3. **步骤 3：补丁应用**

   ```bash
   # 将反向补丁应用到当前工作树
   git apply --3way --index <reverse-patch>
   # --3way: 使用三向合并处理可能的冲突
   # --index: 同时更新暂存区
   ```

4. **步骤 4：提交创建**

   ```bash
   # 创建新的撤销提交
   git commit -m "Revert \"原提交信息\""
   # 或者使用原提交信息模板
   git commit -C target-commit
   ```

## 撤销合并提交

合并提交有**两个或多个父提交**。`-m <父提交序号>` 用于指定**以哪个父提交为基准**来生成撤销提交，从而明确 “**保留哪条分支的代码(保留指定的父提交)，撤销哪条分支的变更**”。

```bash
git revert -m <父提交序号> <合并提交哈希>
```

**`<父提交序号>`**：从 `1` 开始的数字，代表合并提交的父提交顺序（可通过 `git show <合并提交哈希>` 查看）

- 通常，**父 1**是**合并操作的目标分支**（如 `main`）；
- **父 2**是**被合并的源分支**（如 `feature`）。

### 常见场景

* 场景 1：**撤销合并，保留目标分支（如 `main`）的状态**。

  假设将 feature-login 分支合并到 main 后（生成合并提交 abc123），发现合并引入了错误，需要撤销 feature-login 的变更，保留 main 原有的代码

  ```bash
  # -m 1 表示以 父 1（main 分支的最后一个提交）为基准，生成一个新提交，抵消 feature-login 分支带来的所有修改。
  git revert -m 1 abc123
  ```

* 场景 2：**撤销合并，保留源分支（如 feature）的状态**

  （**极少用，通常不符合协作逻辑**）若需撤销合并但保留 `feature-login` 的变更，可指定父 2：

  ```bash
  # 以父 2（feature-login 分支的最后一个提交）为基准，抵消 main 分支原有代码的影响（仅保留 feature-login 的变更）
  git revert -m 2 abc123
  ```

## 与 reset 的对比

`git revert` 与 `git reset` 是两种撤销代码修改的核心命令，但核心逻辑和适用场景截然不同，关键区别如下：

| 维度     | `git revert`           | `git reset`                |
| -------- | ---------------------- | -------------------------- |
| 历史影响 | 保留历史，新增撤销提交 | 改写历史，删除后续提交     |
| 适用分支 | 公共分支（多人协作）   | 本地私有分支或未推送的提交 |
| 操作目标 | 单个 / 多个特定提交    | 分支整体重置到历史节点     |
| 安全性   | 高，可追溯、可恢复     | 低，可能丢失历史，影响协作 |

### 工作机制对比

* **`git revert`**：不删除任何历史提交，而是通过**创建新提交**抵消目标提交的修改（新提交内容与目标提交完全相反）。原提交仍保留在历史中，可通过 `git log` 追溯。
* **`git reset`**：直接**移动分支指针到目标历史提交**，“删除” 该提交之后的所有提交（本地可见，但不可通过正常历史追溯），本质是改写历史。

```bash
# Revert: 添加新提交抵消更改
A - B - C - B'  # B' 抵消 B 的更改

# Reset: 移动分支指针
A - B - C
# 执行 git reset --hard B^
A - B           # C 被"删除"（实际还在对象库中）
```

### 适用场景

- **`git revert`**：适合**公共分支**（如 `main`、`dev`），因不改写历史，不会影响已拉取该分支的团队成员（他人 `pull` 时仅会获取新的撤销提交）。
- **`git reset`**：仅适合**本地私有分支或未推送的提交**，因改写历史，若在公共分支使用，会导致团队成员的本地历史与远程不一致，引发冲突。

### 操作粒度：精确撤销 vs 批量重置

- **`git revert`**：可精确撤销**单个或多个特定提交**，不影响其他提交（即使目标提交之后有新提交，也仅抵消目标提交的修改）。
- **`git reset`**：只能将分支**整体重置到某个历史节点**，该节点之后的所有提交都会被 “移除”（无法单独保留某几个后续提交）。

### 风险：安全 vs 高风险

- **`git revert`**：风险低，即使操作失误，也可通过再次 `revert` 撤销 “撤销提交”，恢复原修改。
- **`git reset`**：风险高，被 “删除” 的提交若未备份，可能永久丢失（需通过 `git reflog` 艰难恢复），且可能导致团队协作混乱。

## 选项

### 基础操作参数（指定提交与撤销范围）

#### `<提交>…`: 提交哈希 / 范围

- **作用**: 直接指定需要挑选的提交（单个、多个或范围），是 `revert` 最基础的用法。
- **单个提交**：`git revert <提交哈希>`
- **多个提交**：`git revert <提交1> <提交2> ...`
- **提交范围**：`git revert <开始>..<结束>`（左开右闭，不含开始）或 `git revert <开始>^..<结束>`（含开始）

#### `-n, --no-commit`：应用撤销但不自动提交

- **作用**: 仅将撤销的修改应用到工作区和暂存区，需手动 `git commit` 完成提交，适合合并多个撤销或调整后再提交。

#### `-m 父编号,--mainline 父编号 `: 撤销合并提交

* **作用**: 合并提交（有多个父提交）需用 `-m` 指定 “以哪个父提交为基准”（即认为哪个分支是 “主分支”，撤销从另一个分支合并的修改）
* 参考[撤销合并提交](#撤销合并提交)

### 冲突处理参数（解决挑选过程中的冲突）

当撤销的提交与当前分支存在冲突时，以下参数用于控制后续操作：

#### `--continue`：解决冲突后继续撤销

- **作用**: 冲突解决后（编辑文件并 `git add` 冲突文件），用 `--continue` 完成当前撤销，并继续处理后续撤销（若撤销多个提交）。

  ```bash
  git revert c8c0747  # 遇到冲突，编辑冲突文件后
  git add <冲突文件>
  git revert --continue  # 完成当前撤销
  ```

#### `--abort`：放弃当前撤销，恢复到操作前状态

- **作用**: 若冲突难以解决或想终止 `revert`，`--abort` 会撤销已做的修改，将分支恢复到撤销前的状态。

  ```bash
  git revert c8c0747  # 遇到冲突
  git revert --abort  # 放弃操作，回到原样
  ```

#### `--skip`：跳过当前冲突的提交，继续处理后续提交

- **作用**: 若当前提交的冲突无需解决，`--skip` 会忽略当前提交，继续处理后续撤销（谨慎使用，可能导致功能不完整）。

  ```bash
  git revert c8c0747 d9e0f1g  # 撤销两个提交，第一个冲突
  git revert --skip  # 跳过 c8c0747，继续处理 d9e0f1g
  ```

### 提交信息控制参数（调整新提交的信息）

#### `--no-edit`：使用默认提交信息，不打开编辑器

- **作用**: 默认 `revert` 会打开编辑器让用户编辑提交信息，`--no-edit` 直接使用默认信息（`Revert "<原提交信息>"`），快速完成撤销

#### `-e, --edit`：默认行为,编辑提交信息

- **作用**: git revert 会让你在提交之前编辑提交信息。默认情况下也是如此。