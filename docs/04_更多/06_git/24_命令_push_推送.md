# git push

## 作用

使用本地引用更新远程仓库引用，同时发送完成**给定引用的必要对象**。

`git push` 的核心作用是：

- 将本地分支中**已提交但未推送到远程**的提交（即 `git log <远程分支>..<本地分支>` 能看到的提交）上传到远程仓库；
- 更新远程仓库中对应分支的指针，使其指向最新的提交（与本地分支同步）；
- 支持推送分支、标签，或删除远程分支 / 标签。

## 概述

```bash
git push [--all | --branches | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]
	   [--repo=<仓库>] [-f | --force] [-d | --delete] [--prune] [-q | --quiet] [-v | --verbose]
	   [-u | --set-upstream] [-o <字符串> | --push-option=<字符串>]
	   [--[no-]signed|--signed=(true|false|if-asked)]
	   [--force-with-lease[=<引用名>[:<expect>]] [--force-if-includes]]
	   [--no-verify] [<仓库> [<引用规范>…​]]
```

## 推送的内容

`git push` 推送的是一个完整的**对象图谱**，包括提交历史、文件快照和引用更新。**以及更新远程引用指针**。

1. **提交对象（Commits）**

   ```bash
   # 推送的是提交历史，不是单个文件
   A - B - C - D [本地 main]
        \
         E - F [远程 origin/main]

   # 执行 git push 后，推送的是 C 和 D 两个提交
   ```

2. 相关的 Git 对象

   - **提交对象**：包含作者、时间、提交信息、树对象指针
   - **树对象**：代表目录结构，包含文件列表和对应的 blob 指针
   - **Blob 对象**：文件内容的快照
   - **父提交指针**：维护提交历史关系

**不会被推送的内容（关键区别）**，`git push` 仅推送 “已提交到本地版本库的内容”，以下内容**不会被推送**：

1. **工作区的未暂存修改**（`git status` 中 `untracked files` 或 `modified but not staged` 的内容）；
2. **暂存区未提交的修改**（`git add` 后但未 `git commit` 的内容）；
3. **`.gitignore` 中忽略的文件**（即使手动 `git add`，若在 `.gitignore` 中，默认也不会被跟踪和推送）；
4. **本地的 stash 内容**（`git stash` 暂存的修改，需 `git stash pop` 并提交后才能推送）；
5. **其他分支的未推送提交**（除非显式推送该分支，或使用 `--all`）；
6. **本地仓库的配置文件**（如 `.git/config`）、钩子脚本（`.git/hooks/`）等本地元数据。

## 推送的源引用

`git push` 的源引用指的是**本地仓库中将要被推送到远程仓库的内容来源**。它决定了 “从本地的哪个引用获取数据推送到远程”，是控制推送范围的核心要素。

### 源引用的指定方式

1. **显式指定源引用**: 通过[引用规范](./refspec.html#git-push-中的引用规范-推送本地-→-远程) `<src>:<dst>` 明确指定本地源引用

   ```bash
   # 源引用是本地 dev 分支（refs/heads/dev），推送到远程 develop 分支
   git push origin dev:develop
   ```

2. **省略源引用的简化形式**: 当省略引用规范中的 `<src>` 或直接使用简化命令时，源引用会通过上下文或配置推断

   ```bash
   git push origin main  # 等价于 git push origin main:main

   git push  # 等价于 git push origin dev:dev
   ```

| **推送命令**                   | **推送来源**      | **目标**          |
| :----------------------------- | :---------------- | :---------------- |
| `git push`                     | 当前分支          | 上游分支          |
| `git push origin main`         | 本地 main 分支    | 远程 main 分支    |
| `git push origin feature:main` | 本地 feature 分支 | 远程 main 分支    |
| `git push origin HEAD:feature` | 当前提交          | 远程 feature 分支 |
| `git push --tags`              | 所有本地标签      | 远程仓库标签      |
| `git push --all`               | 所有本地分支      | 远程仓库          |

### 推送来源的数据流

```text
本地仓库 → 推送来源 → 网络传输 → 远程仓库
    ↓           ↓           ↓         ↓
refs/heads/ 提交对象、   打包的   更新远程
main        树对象、    包文件    refs/heads/
            blob对象              main
```

## 推送的目标引用

`git push` 的目标引用指的是**远程仓库中将被更新的引用位置**。它决定了 “本地数据推送到远程的哪个引用上”，直接控制远程仓库的引用如何被更新。

### 目标引用的定义与本质

目标引用（`<dst>`）是远程仓库中的一个引用（ref），本质是远程仓库 `.git/refs/` 目录下的指针文件（内容为提交哈希），用于标识远程的分支、标签等。

在 `git push` 中，目标引用的作用是：告诉 Git“将本地源引用（`<src>`）的数据推送到远程的哪个引用上，并更新该远程引用的指针”。

### 目标引用的指定方式

1. **显式指定目标引用**: 通过[引用规范](./refspec.html#git-push-中的引用规范-推送本地-→-远程) `<src>:<dst>` 明确指定远程目标引用，格式为：`git push <远程标识> <src>:<dst>`

   ```bash
   # 本地 dev 分支（<src>）推送到远程 origin 的 develop 分支（<dst>）
   git push origin dev:develop

   # 本地 v2.0 标签（<src>）推送到远程 origin 的 v2.0 标签（<dst>）
   git push origin v2.0:v2.0

   # 本地当前分支（<src> 为 HEAD）推送到远程 origin 的 new-feature 分支（<dst>）
   git push origin HEAD:new-feature
   ```

2. **省略目标引用的简化形式**: 当省略引用规范中的 `<dst>` 时，目标引用会默认与源引用（`<src>`）同名，即 `<src>:<src>`

   ```bash
   git push origin main  # 等价于 git push origin main:main

   git push  # 等价于 git push origin dev:dev
   ```

3. **特殊场景：删除远程引用（目标引用为被删除对象）**: 若源引用为空（即 `:<dst>`），目标引用 `<dst>` 表示 “要被删除的远程引用”

   ```bash
   # 删除远程 origin 的 old-feature 分支（目标引用是 old-feature）
   git push origin :old-feature  # 等价于 git push origin --delete old-feature
   ```

| **目标类型** | **示例命令**               | **目标引用**      | **效果**             |
| :----------- | :------------------------- | :---------------- | :------------------- |
| **同名分支** | `git push origin main`     | `refs/heads/main` | 更新远程 main 分支   |
| **不同分支** | `git push origin dev:main` | `refs/heads/main` | 用 dev 更新远程 main |
| **标签**     | `git push origin v1.0`     | `refs/tags/v1.0`  | 创建/更新远程标签    |
| **删除分支** | `git push origin :old`     | `refs/heads/old`  | 删除远程 old 分支    |
| **所有分支** | `git push origin --all`    | `refs/heads/*`    | 更新所有匹配分支     |
| **所有标签** | `git push origin --tags`   | `refs/tags/*`     | 更新所有匹配标签     |

## 快进式推送和非快进式推送

**快进式推送（fast-forward push）** 和 **非快进式推送（non-fast-forward push）** 是两种核心的推送场景，决定了 Git 是否允许直接推送本地分支到远程，本质上与 “本地分支历史是否与远程分支历史兼容” 相关。

### 快进式推送

“快进”（fast-forward）指的是：**本地分支的历史是远程对应分支历史的 “直接延续”**—— 即远程分支的最新提交是本地分支历史的一部分（远程分支是本地分支的祖先），本地分支在远程分支的基础上新增了提交，没有历史分叉。**推送时远程分支可以直接 “向前移动指针” 到本地分支的最新提交，无需创建新的合并提交**。

```text
本地分支: A — B — C — D — E
                   /
远程分支: A — B — C


推送后:
远程分支: A — B — C — D — E
```

### 非快进式推送

“非快进”（non-fast-forward）则是：**本地分支与远程分支的历史出现了 “分叉”**—— 远程分支有本地没有的新提交，本地分支也有远程没有的新提交，两者的历史无法直接衔接，推送时无法通过 “移动指针” 完成同步，属于非快进式推送。

```text
本地分支: A — B — C — D — E # 基于 C 进行了新提交 D 和 E。
                 |
远程分支: A — B — C — F — G # 基于 C 进行了新提交 F 和 G（可能由其他开发者推送）。

强制推送后: 远程的 F、G 提交会被丢弃
远程分支: A — B — C — D — E
```

非快进式推送会被 Git **默认拒绝**，因为直接推送会覆盖远程的新提交（`X`），导致数据丢失。

#### 如何处理非快进式推送？

- **先整合远程的新提交到本地，使本地历史成为远程的超集（转为快进式），再推送**。

- **特殊情况：强制非快进式推送（谨慎！）**: 可使用 `--force` 或 `--force-with-lease` 强制推送（非快进式）

  ```bash
  # 强制推送（直接覆盖远程历史，高风险）
  git push --force origin main

  # 更安全的强制推送（检查远程是否被他人修改，避免覆盖他人提交）
  git push --force-with-lease origin main
  ```

## 选项

### 基础行为参数（指定推送目标与跟踪关系）

这类参数用于定义 “推送到哪个远程、哪个分支”，以及设置本地与远程的跟踪关系。

#### `<远程标识>`：指定推送的远程仓库

- **作用**：明确将本地代码推送到哪个远程仓库（如 `origin`、`upstream`），不指定则使用当前分支配置的默认远程（通过 `branch.<分支>.remote` 定义）
- **语法**：`git push <远程标识> [其他参数]`

#### `<引用规范>`：指定推送的源引用与目标引用

- **作用**：`<本地引用>` 是推送的本地来源（分支 / 标签），`<远程引用>` 是远程接收的目标（分支 / 标签），核心用于自定义本地与远程的映射关系（如重命名推送）
- **语法**：`git push <远程标识> <本地引用>:<远程引用>`

#### `-u, --set-upstream`：推送并设置跟踪关系

- **作用**：**首次推送本地分支到远程时，自动将本地分支与远程分支关联（设置跟踪关系）**，后续可直接用 `git push` 推送，无需重复指定远程和分支。

- **语法**：`git push -u <远程标识> <本地分支>:<远程分支>`

- **示例**：

  ```bash
  # 推送本地 new-feature 到远程 new-feature，同时设置跟踪关系
  git push -u origin new-feature:new-feature
  # 后续推送可简化为：git push
  ```

### 推送范围控制参数（控制推送的分支 / 标签）

这类参数用于精准控制推送的范围，避免推送无关分支或标签

#### `--all, --branches`：推送所有本地分支

- **作用**：推送所有分支（即`refs/heads/`下的引用）；不能与其他 `< 引用规范 >` 一起使用，不推送标签
- **语法**：`git push <远程标识> --all`
- **注意**：可能推送无关分支（如本地测试分支），团队协作中慎用。

#### `--tags`：推送所有本地标签

- **作用**：默认 `git push` 不推送标签，`--tags` 会推送本地所有标签（`refs/tags` 下的所有引用）到远程。
- **语法**：`git push <远程标识> --tags`

### 标签与引用管理参数

专门用于标签推送、删除远程引用的参数，精准控制远程的标签和分支。

#### `-d, --delete`：删除远程分支 / 标签

- **作用**：删除远程仓库的指定分支或标签，等价于 `git push <远程> :<远程引用>`。
- **语法**：`git push --delete <远程标识> <远程引用>`

#### `--no-tags`：推送时不推送任何标签

- **作用**：强制忽略本地标签，仅推送分支（覆盖 `--tags` 或全局标签推送配置）
- **语法**：`git push --no-tags <远程标识> <分支>`

### 强制操作参数（处理非快进式推送）

当本地分支历史与远程冲突（如本地改写历史后），默认 `git push` 会拒绝推送，这类参数用于强制同步，需谨慎使用。

#### `-f,--force`：强制推送（覆盖远程历史）

- **作用**：忽略非快进式更新（本地与远程历史分叉），强制用本地分支覆盖远程分支，会直接丢失远程已有的、本地没有的提交。

- **语法**：`git push --force <远程标识> <分支>`

- **风险**：破坏团队协作，可能覆盖他人提交，仅在确认远程历史可丢弃时使用（如远程分支被错误提交污染）。

- **示例**：

  ```bash
  # 强制推送本地 main 到远程 main，覆盖远程历史（高风险）
  git push -f origin main
  ```

### 输出控制参数（调整推送信息展示）

这类参数控制推送的输出详略，用于调试、静默执行或查看详细日志。

#### `-v, --verbose`: 详细输出推送过程

- **作用**：显示推送的详细信息，包括：远程仓库 URL、推送的提交哈希、文件差异、远程引用更新状态等，便于调试。
- **语法**：`git push -v <远程标识> <分支>`

#### `-q, --quiet`：静默模式，仅输出错误

- **作用**：不显示正常的推送进度、提交信息等，仅在推送失败时输出错误提示，适合脚本中使用。
- **语法**：`git push -q <远程标识> <分支>`

### 特殊功能参数（适配特定场景）

#### `-n, --dry-run`：模拟推送，不实际执行

- **作用**：显示 “如果执行推送会发生什么”（如下载的对象、更新的远程引用、删除的分支），但不实际推送到远程，用于预览推送结果，避免误操作。
- **语法**：`git push --dry-run <远程标识> <分支>`

#### `--[no-]verify`: 是否执行预推送钩子

- **作用**：Git 允许通过 `pre-push` 钩子脚本（`.git/hooks/pre-push`）在推送前执行校验（如代码 lint、测试），`--[no-]verify` 控制是否执行该钩子
  - `--verify` 默认行为, 执行钩子
  - `--no-verify` 会跳过该钩子，强制推送。
- **语法**：`git push --no-verify <远程标识> <分支>`

#### `--prune`: 清理远程仓库

- **作用**: 在推送本地引用（分支、标签）到远程仓库后，Git 会额外检查远程仓库的引用列表，**删除所有 “本地不存在但远程存在的、与推送范围相关的引用”**。

- **清理范围**：仅针对 “与推送类型一致的引用”。

  | 推送的引用类型          | 清理的远程引用类型         | 说明                                   |
  | ----------------------- | -------------------------- | -------------------------------------- |
  | 所有分支(--all)         | 远程分支（`refs/heads/*`） | 推送分支时，仅删除远程中本地没有的分支 |
  | 分支（`refs/heads/*`）  | 远程分支（`refs/heads/*`） | 推送分支时，仅删除远程中本地没有的分支 |
  | 标签（`refs/tags/*`）   | 远程标签（`refs/tags/*`）  | 推送标签时，仅删除远程中本地没有的标签 |
  | 混合推送（分支 + 标签） | 对应类型的分支和标签       | 同时清理远程中本地没有的分支和标签     |

- **注意**：直接使用 `git push` 默认情况下不会清理的, 因为 `git push` 默认是从当前分支的 `branch.<分支>.` 信息中推断出来的引用规范, 并不会影响其他分支

  ```bash
  $ git push # 在 main 分支上

  # 等同于 - 此时不是清理其他分支
  $ git push refs/heads/main:refs/heads/main

  # 使用 --all 或 refs/heads/* 可以清理
  $ git push refs/heads/*:refs/heads/* --prune
  ```

- **与 git fetch --prune 的区别**，方向和对象完全不同：

  | 命令                | 作用对象              | 清理逻辑                                                                                                          | 目的                               |
  | ------------------- | --------------------- | ----------------------------------------------------------------------------------------------------------------- | ---------------------------------- |
  | `git fetch --prune` | 本地的 “远程跟踪分支” | 删除本地 `refs/remotes/<远程>/*` 中，远程已删除的分支对应的跟踪分支（如远程删除 `dev`，本地 `origin/dev` 被删除） | 保持本地跟踪分支与远程实际分支一致 |
  | `git push --prune`  | 远程仓库的 “实际引用” | 删除远程 `refs/heads/*` 或 `refs/tags/*` 中，本地已删除的对应引用（如本地删除 `dev`，远程 `dev` 被删除）          | 保持远程引用与本地引用集合一致     |
