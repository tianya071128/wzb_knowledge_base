# git 分支

## 提交的基本原理

在进行提交操作时，Git 会保存一个提交对象（commit object）。

**提交对象会包含一个指向暂存内容快照的指针，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针**。

首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象。

当使用 git commit 进行提交操作时，Git 会先计算每一个子目录的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。

![image-20250805102734301](/img/343.png)

做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。

![image-20250805103032835](/img/344.png)

## 分支的基本原理

Git 分支的核心原理可以用一句话概括：**分支本质是一个指向特定提交（Commit）的轻量指针，所有分支操作本质上都是在移动这些指针**。

### 分支的底层存储：指针文件

在 Git 仓库的 `.git/refs/heads/` 目录下，每个分支对应一个**文本文件**，文件内容只有一行 —— 指向该分支最新提交的哈希值（SHA-1 字符串）。

* 分支的创建**不复制工作区文件**，仅创建一个 tiny 指针文件，因此速度极快。
* 分支的 “内容” 由它指向的提交及历史提交链决定。

### HEAD 指针：当前分支的 “游标”

Git 中有一个特殊指针 `HEAD`（存储在 `.git/HEAD` 文件中），用于标记**当前所在的分支**。

文件内容:

```text
ref: refs/heads/testing # 当前分支文件的路径
```

### 分支的操作：指针的分离

* **创建分支时，Git 会生成一个新指针，指向当前提交**；后续提交只会移动当前分支的指针，其他分支指针不变。
* **切换分支时, Git 将 HEAD 指针指向切换的分支，并且将工作目录回复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支**。
* **删除分支本质是删除 `.git/refs/heads/dev` 这个指针文件，不会删除任何提交（提交会被 Git 垃圾回收机制清理，若无人引用）**

![image-20250805104734817](/img/345.png)

## 切换分支的前提条件

切换分支前，需确保工作区和暂存区的修改已妥善处理，否则可能导致修改丢失或冲突：

* **未提交的修改与目标分支兼容**: Git 会自动携带未提交的修改切换到新分支（如果文件在两个分支中没有冲突）
* **存在未提交的修改且可能冲突**: Git 会阻止切换

此时的解决方法:

- 提交修改：`git add . && git commit -m "暂存修改"`
- 暂存修改（临时保存）：`git stash`（切换回来后用 `git stash pop` 恢复）
- 放弃修改（危险！）：`git reset --hard && git clean -fd`


## 分支合并

**将一个分支的修改整合到另一个分支的过程，是协作开发中的核心操作**

### 合并操作

步骤如下：

1. **切换到目标分支**（接收合并的分支，如 `main`）：
2. **确保目标分支是最新的**（拉取远程更新）：
3. **执行合并命令**（将 `feature` 分支合并到当前分支）：

```bash
git checkout main  # 或 git switch main

git pull origin main

git merge feature
```

### 合并的两种类型

Git 会根据分支历史自动选择合并方式：

#### 快进合并（Fast-forward）

- **适用场景**：目标分支是当前分支的直接延续（无分叉），例如 `feature` 分支基于 `main` 最新提交创建，且 `main` 在此期间未更新。

- **操作**：Git 直接将 `main` 分支指针移动到 `feature` 分支的最新提交（不创建新提交）。

- **示例**:

  ```text
  合并前：          合并后：
  A--B--C (main)    A--B--C--D--E (main)
         \                      ^
          D--E (feature)        (feature)
  ```

#### 三方合并（Three-way merge）

- **适用场景**：分支有分叉（如 `main` 在 `feature` 开发期间有新提交）。

- **操作**：Git 找到两个分支的 “最近共同祖先”，**创建一个新的 “合并提交”（有两个父节点）**，整合两边的修改。

- **示例**：

  ```text
  合并前：            合并后：
  A--B--C--F (main)   A--B--C--F--G (main)
         \               ^     /
          D--E (feature)  \   /
                           D--E (feature)
  ```

### 合并冲突

当两个分支修改了同一文件的同一部分时，Git 无法自动合并，会提示冲突。

**当文件冲突时，会将文件标记为未合并状态。在解决了文件里的冲突之后，对文件使用 `git add` 命令来将其标记为冲突已解决。**

解决步骤:

1. **查看冲突文件**：冲突部分会被特殊标记包围

2. **手动编辑文件**：保留需要的内容，删除冲突标记（`<<<<<<<`、`=======`、`>>>>>>>`）

3. **标记为已解决**：

   ```bash
   git add <冲突文件>  # 单个文件
   # 或 git add . 标记所有冲突文件
   ```

4. **完成合并提交**：

   ```bash
   git commit  # 会自动生成合并提交信息，可修改后保存
   ```

#### 放弃合并

当解决冲突失败时使用，回到合并前的状态

```bash
git merge --abort
```

## 远程分支

### 跟踪分支

**远程跟踪分支（Remote Tracking Branch）** 是本地仓库中用来「镜像」远程仓库分支状态的特殊分支，它反映了上次与远程仓库同步时对应的远程分支的状态。

简单来说，它就像一个「本地副本」，记录着远程仓库里各分支的最新提交，帮助你在本地了解远程分支的变化，而无需每次都连接远程仓库。

#### 特点

1. **命名格式**

   远程跟踪分支的命名格式为 `远程仓库名/分支名`，例如：

   - `origin/main`：表示远程仓库 `origin` 的 `main` 分支在本地的跟踪记录
   
2. **自动更新**

   当执行 `git fetch` 或 `git pull` 时，Git 会自动更新远程跟踪分支，使其与远程仓库的对应分支保持一致。

3. **只读**

   远程跟踪分支是「只读」的，你无法直接在上面提交修改，只能通过与远程仓库同步（`fetch`/`pull`）来更新它。

#### 作用

1. **查看远程分支状态**：通过远程跟踪分支，你可以在本地查看远程分支的最新状态，例如：

   ```bash
   # 查看远程跟踪分支的提交历史
   git log origin/main
   
   # 比较本地分支与远程跟踪分支的差异
   git diff main origin/main
   ```

2. **作为本地分支的「参考基准」**：本地分支通常会「跟踪」一个远程跟踪分支（如 `main` 跟踪 `origin/main`），这样执行 `git pull` 时，Git 就知道该从哪个远程分支拉取更新。

3. **避免直接操作远程仓库**：无需频繁连接远程仓库，通过本地的远程跟踪分支就能了解远程变化，减少网络依赖。

## 变基

