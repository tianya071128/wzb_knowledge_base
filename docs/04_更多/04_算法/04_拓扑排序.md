# 拓扑排序

拓扑排序（Topological Sorting）是针对有向无环图（DAG, Directed Acyclic Graph） 的一种顶点排序方式，排序后所有有向边的起点都在终点之前。它的核心价值是解决 “依赖顺序” 问题，比如任务调度中先完成前置任务、课程学习中先修完基础课程等场景。

## 核心概念

1. **适用范围**：仅能对有向无环图执行拓扑排序，若图中存在环，则不存在拓扑序列（比如循环依赖的任务无法确定执行顺序）。
2. **结果特性**：一个 DAG 的拓扑排序结果**不唯一**。例如，若图中存在三个无依赖的顶点，它们的顺序可以任意排列。
3. **核心作用**：梳理依赖关系，确定符合规则的执行 / 处理顺序。

## 实现算法

拓扑排序的两种主流实现方式：

### Kahn 算法（基于入度 + 队列）

该算法的核心思路是**逐步移除入度为 0 的顶点**（入度为 0 表示无前置依赖），并同步更新其邻接点的入度，最终得到拓扑序列。**若最终序列长度小于顶点数，则说明图中存在环**。

* **算法步骤**
  1. 计算所有顶点的入度，并构建邻接表存储图结构。
  2. 初始化队列，将所有入度为 0 的顶点加入队列。
  3. 循环取出队列顶点，将其加入拓扑序列；遍历该顶点的所有邻接点，将邻接点的入度减 1。
  4. 若邻接点入度减为 0，则加入队列。
  5. 循环结束后，若序列长度等于顶点数，返回序列；否则返回空（存在环）。
  
* **实现**

  ```js
  /**
   * Kahn算法实现拓扑排序
   * @param {number} n 顶点数（顶点编号0~n-1）
   * @param {number[][]} edges 边的集合，[[u1,v1],[u2,v2]]表示u→v的边
   * @returns {number[]} 拓扑序列，若有环返回空数组
   */
  function topologicalSortKahn(n, edges) {
      // 1. 构建邻接表和入度数组
      const adj = Array.from({ length: n }, () => []);
      const inDegree = new Array(n).fill(0);
      for (const [u, v] of edges) {
          adj[u].push(v); // u指向v，添加邻接关系
          inDegree[v]++; // v的入度+1
      }
  
      // 2. 初始化队列，加入所有入度为0的顶点
      const queue = [];
      for (let i = 0; i < n; i++) {
          if (inDegree[i] === 0) {
              queue.push(i);
          }
      }
  
      const result = [];
      // 3. 处理队列中的顶点
      while (queue.length > 0) {
          const u = queue.shift();
          result.push(u);
  
          // 遍历u的邻接点，更新入度
          for (const v of adj[u]) {
              inDegree[v]--;
              if (inDegree[v] === 0) {
                  queue.push(v);
              }
          }
      }
  
      // 4. 若序列长度不等于顶点数，说明有环
      return result.length === n ? result : [];
  }
  ```

### DFS 算法（基于递归 + 栈，利用回溯特性）

该算法的核心思路是**深度优先遍历图**，当一个顶点的所有邻接点都遍历完成后，将该顶点入栈。遍历结束后逆序输出栈，即为拓扑序列。**若遍历中检测到回边（指向已访问但未完成遍历的顶点），则说明图中有环**。

* **算法步骤**

  1. 构建邻接表，并用三个状态标记顶点：未访问、访问中、已完成。
  2. 遍历所有未访问顶点，对每个顶点执行 DFS。
  3. DFS 中，先标记顶点为 “访问中”，递归遍历其所有邻接点。
  4. 若邻接点处于 “访问中”，说明存在环；若邻接点未访问，则继续递归。
  5. 顶点的所有邻接点遍历完成后，标记为 “已完成” 并入栈。
  6. 遍历结束后，逆序输出栈得到拓扑序列。

* **实现**

  ```js
  /**
   * DFS算法实现拓扑排序
   * @param {number} n 顶点数（顶点编号0~n-1）
   * @param {number[][]} edges 边的集合
   * @returns {number[]} 拓扑序列，若有环返回空数组
   */
  function topologicalSortDFS(n, edges) {
      // 1. 构建邻接表
      const adj = Array.from({ length: n }, () => []);
      for (const [u, v] of edges) {
          adj[u].push(v);
      }
  
      const result = [];
      const status = new Array(n).fill(0); // 0:未访问 1:访问中 2:已完成
      let hasCycle = false;
  
      // 2. 递归DFS函数
      const dfs = (u) => {
          if (hasCycle) return;
          status[u] = 1; // 标记为访问中
          for (const v of adj[u]) {
              if (status[v] === 0) {
                  dfs(v);
              } else if (status[v] === 1) {
                  // 遇到访问中的顶点，存在环
                  hasCycle = true;
                  return;
              }
          }
          status[u] = 2; // 标记为已完成
          result.push(u); // 入栈
      };
  
      // 3. 遍历所有未访问顶点
      for (let i = 0; i < n; i++) {
          if (status[i] === 0 && !hasCycle) {
              dfs(i);
          }
      }
  
      // 4. 有环则返回空，否则逆序输出
      return hasCycle ? [] : result.reverse();
  }
  ```

### 关键要点

1. **环检测**：两种算法均能检测图中是否存在环，这是拓扑排序的前置校验核心。

2. **算法对比**

   | 特性     | Kahn 算法                  | DFS 算法                                  |
   | -------- | -------------------------- | ----------------------------------------- |
   | 实现方式 | 队列 + 入度                | 递归 + 栈 + 状态标记                      |
   | 核心优势 | 直观易理解，可处理大规模图 | 实现简洁，无需维护入度数组                |
   | 适用场景 | 需逐步输出拓扑序列的场景   | 适合小规模图，或与其他 DFS 操作结合的场景 |

3. **时间复杂度**：两种算法的时间复杂度均为 *O*(*n*+*e*)（n 为顶点数，e 为边数），需遍历所有顶点和边。

## 典型应用场景

1. **任务调度**：例如项目中任务 A 依赖任务 B，任务 B 依赖任务 C，通过拓扑排序确定任务执行顺序。
2. **课程安排**：大学选课中，部分课程需修完前置课程才能选修，拓扑排序可生成合理选课顺序。
3. **编译依赖**：编译器处理代码模块时，按拓扑顺序编译可解决模块间的依赖问题。
4. **事件驱动**：异步任务中，按依赖关系排序确保任务执行的正确性。





