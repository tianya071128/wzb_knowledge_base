# HTTP/2

HTTPS 是用来解决安全方面的问题，**HTTP2 是用来解决性能方面的问题**。

Google 率先发明了 SPDY 协议，随后互联网标准化组织 IETF 以 SPDY 为基础，综合其他多方的意见，推出了 “HTTP/2”。

可通过 `Wireshark` 工具打开[文件](https://github.com/tianya071128/wenshuli/blob/master/client/demo/%E6%8A%93%E5%8C%85/HTTP2%20%E8%BF%9E%E6%8E%A5.pcapng)查看

## 为什么不叫 HTTP/2.0？

HTTP/2 工作组认为以前的“1.0”“1.1”造成了很多的混乱和误解，让人在实际的使用中难以区分差异，所以就决定 HTTP 协议不再使用小版本号（minor version），只使用大版本号（major version），从今往后 HTTP 协议不会出现 HTTP/2.0、2.1，只会有“HTTP/2”“HTTP/3”……

## 兼容 HTTP/1

HTTP/2 需要兼容 HTTP/1，否则就会破坏互联网上无数现有的资产，这方面 TLS 已经有了先例（为了兼容 TLS1.2 不得不进行“伪装”）。

为了保持功能上的兼容，所以 HTTP/2 把 HTTP 分解成了“语义”和“语法”两个部分：

- **“语义”层不做改动，与 HTTP/1 完全一致**。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。
- 主要对 "语法" 层面进行改动，完全变更了 HTTP 报文的传输格式。

::: warning HTTP/2 并没有引入新的协议名

与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议。

让浏览器或者服务器去自动升级或降级协议，免去了选择的麻烦，让用户在上网的时候都意识不到协议的切换，实现平滑过渡。

:::

## HTPP/2 特性

### 头部压缩

HTTP/1 里可以用头字段 “Content-Encoding” 指定 Body 的编码方式，比如用 gzip 压缩来节约带宽，但报文的另一个组成部分——Header 却被无视了，没有针对它的优化手段。

由于报文 Header 一般会携带“User Agent”“Cookie”“Accept”“Server”等许多固定的头字段，并且请求响应报文里有很多字段值都是重复的。

所以 HTTP/2 使用头部压缩进行优化，专门开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。

### 二进制格式

HTTP/1 使用纯文本形式的报文，而 HTTP/2 不再使用肉眼可见的 ASCII 码，而是向下层的 TCP/IP 协议“靠拢”，全面采用二进制格式。二进制里只有“0”和“1”，可以严格规定字段大小、顺序、标志位等格式，解析起来没有歧义，实现简单，而且体积小、速度快，做到“内部提效”。

把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。

![image](/img/314.jpg)

### 虚拟的“流”

消息的“碎片”到达目的地后应该怎么组装起来呢？

HTTP/2 为此定义了一个“流”（Stream）的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个**唯一的流 ID**。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。

因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。

在“流”的层面上看，消息是一些有序的“帧”序列，而在“连接”的层面上看，消息却是乱序收发的“帧”。**多个请求 / 响应之间没有了顺序关系，不需要排队等待**，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率。

![image](/img/315.jpg)

::: tip 为什么"流"是虚拟的?
客户端将多个请求分成不同的流，然后每个流里面在切成一个个帧，发送的时候是按帧发送的。每个帧存着一个流 ID 来表示它属于的流。服务端收到请求的时候将帧按流 ID 进行拼接。从传输的角度来看流是不存在的，只是看到了一个个帧，所以说流是虚拟的。
:::

### 服务器推送

基于虚拟"流"，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。

### 强化安全

出于兼容的考虑，HTTP/2 延续了 HTTP/1 的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。

但由于 HTTPS 已经是大势所趋，**而且主流的浏览器 Chrome、Firefox 等都公开宣布只支持加密的 HTTP/2，所以“事实上”的 HTTP/2 是加密的**。也就是说，互联网上通常所能见到的 HTTP/2 都是使用“https”协议名，跑在 TLS 上面。

为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。

在 HTTP/2 标准制定的时候（2015 年）已经发现了很多 SSL/TLS 的弱点，而新的 TLS1.3 还未发布，所以加密版本的 HTTP/2 在安全方面做了强化，要求下层的通信协议必须是 TLS1.2 以上，还要支持前向安全和 SNI，并且把几百个弱密码套件列入了“黑名单”，比如 DES、RC4、CBC、SHA-1 都不能在 HTTP/2 里使用，相当于底层用的是“TLS1.25”。

## HTTP/2 的协议栈

![image](/img/316.jpg)

## 参考

[极客时间-时代之风（上）：HTTP/2 特性概览](https://time.geekbang.org/column/article/112036?screen=full)

[stackoverflow-TLS 连接确定 HTTP 版本](https://stackoverflow.com/questions/36500050/what-if-an-http-1-1-client-talk-to-an-http-2-only-server-and-what-if-an-http-2-c/36501371#36501371)
