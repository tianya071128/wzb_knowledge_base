# HTTP/2 内核剖析

## 如何连接 HTTP/2？

HTTP/2 并没有引入新的协议名，那么就需要客户端和服务端协商 HTTP 版本号问题。

HTTP/2 “事实上”是基于 TLS 的(目前浏览器几乎只支持 HTTPS 协议的 HTTP/2)，所以会在 TLS 握手阶段过程客户端和服务端就对 HTTP 版本进行协商

### TLS 握手过程的 HTTP 版本协商

以下是基于 TLSv1.2 版本的握手：

1. 客户端发送 “Client Hello”相关消息时，客户端会把支持的 HTTP 版本告诉服务器：

   ![enter image description here](/img/141.png)

2. 服务器回复 "Server Hello" 相关消息时，可以将自己支持的 HTTP 版本告诉客户端：

   ![image-20220624154020138](/img/142.png)

3. 客户端回复消息：

   - 如果服务器也支持多个 HTTP 版本，客户端就会选择一个版本进行通信。

   - **如果服务器选定了一个版本的话，客户端就不会进行选择**，下图就是当服务器支持多个 HTTP 版本时，客户端回复内容

     ![enter image description here](/img/143.png)

**总之，在这一步需要协商出客户端和服务端通信的 HTTP 版本**

### 连接前言

当在 TLS 确定了 HTTP 版本后，如果确定是使用 HTTP/2 时，那么**客户端必须要发送一个“连接前言”（connection preface）**，用来确认建立 HTTP/2 连接。

这个“连接前言”是标准的 HTTP/1 请求报文，使用纯文本的 ASCII 码格式，请求方法是特别注册的一个关键字“PRI”，全文只有 24 个字节：

```tex
PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n
```

当服务器没有拒绝这个请求后，那么后续双方就会使用 HTPP/2 进行收发消息

![image](/img/144.png)

## 头部压缩

使用 **“HPACK”** 算法来压缩头部数据。

“HPACK”算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是 **“字典”**（这有点类似 brotli），压缩和解压缩就是查表和更新表的操作。

### 废除起始行

为了方便管理和压缩，**HTTP/2 废除了原有的起始行概念**，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，并且给这些“不是头字段的头字段”起了个特别的名字——“伪头字段”（pseudo-header fields）。而起始行里的版本号和错误原因短语因为没什么大用，顺便也给废除了。

为了与“真头字段”区分开来，这些“伪头字段”会在名字前加一个“:”，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。

![image](/img/317.jpg)

### 静态表

通过废除起始行，这样全都是“Key-Value”形式的字段，于是 HTTP/2 就为一些最常用的头字段定义了一个只读的 **“静态表”**（Static Table）。

如下图所示，这样客户端和服务端只要查表就可以知道字段名和对应的值，比如数字“2”代表“GET”，数字“8”代表状态码 200。

![image](/img/318.jpg)

### 动态表

对于有些字段只有 Key 没有 Value(例如:user-agent 的 value 每个客户端的都不一样,只有连接后才知道具体值)，或者是自定义字段，这就要用到“动态表”（Dynamic Table），它添加在静态表后面，结构相同，但会在编码解码的时候**随时更新**。

例如：第一次发送请求时的“user-agent”字段长是一百多个字节，用哈夫曼压缩编码发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号“65”。那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。

![image](/img/319.jpg)
