---
title: HTTPS 如何解决安全性？
date: 2021-10-21 15:00:00
permalink: /https/security
categories:
  - 其他
  - HTTPS
tags:
  - null
---

# HTTPS 解决安全性

由上一节可知，安全性一般有四大特性：机密性、完整性，身份认证和不可否认

## TLS 解决机密性

实现机密性通过数据加密解决。常见的几种概念：

- 密钥：解密的“钥匙”。“密钥”就是一长串的数字，但约定俗成的度量单位是“位”（bit），而不是“字节”（byte）。
- 明文：加密前的数据。
- 密文：加密后的数据。
- 解密：使用密钥还原明文的过程。
- 加密算法：加密解密的操作过程

按照密钥的使用方式，加密可以分为两大类；对称加密和非对称加密

### 对称加密

指加密和解密使用的密钥都是同一个，是”对称“的。**注意在于保证密钥的安全。**

**最大问题在于：如何保证密钥的安全**

![img](/img/11.png)

::: tip 对称加密算法

TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES 和 ChaCha20。

:::

### 非对称加密

非对称加密有两个密钥，一个“公钥”，一个“私钥”。两个密钥是不同的，公钥是可以公开给任何人使用，私钥必须严格保密。

**非对称加密有个“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能通过私钥加密**

**这样的话，服务器只要掌握了私钥，就可以确保浏览器的报文安全性，而即使中间攻击者截获了服务器响应报文，但是中间攻击者没有私钥，也就不能用私钥进行加密**

![img](/img/12.png)

::: tip 非对称加密算法

非对称加密算法的设计要比对称算法难得多，在 TLS 里只有很少的几种，比如 DH、DSA、RSA、ECC 等。

RSA 可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。

...

:::

### 混合加密

对称加密最大的问题：如何把密钥安全的传递给对方，也就是“密钥交换”。因为只要持有密钥就可以进行加解密。

非对称加密的问题：解决了对称加密的“密钥交换"问题(私钥不需要交换)，但是加解密的运算速度很慢，效率很低。

**基于如上(简述)，TLS 采用的策略是混合加密。**

**混合加密：一开始使用非对称加密，解决密钥交换的问题，然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。**

![img](/img/13.png)

## TLS 解决完整性

混合加密保证了数据的机密性，但是离安全还差很远。

黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。因为没有完整性保证，服务器只能“照单全收”，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。

另外，黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了。

### 摘要算法

摘要算法（散列函数、哈希函数）：能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要‘字符串，就好像这段数据的一个数字”指纹“。并且无法从摘要中推算出原文。

::: tip 常用摘要算法

TLS 推荐使用的是 SHA-1 的后继者：SHA-2。SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。

:::

### 解决完整性

摘要算法保证了摘要和原文是完全等价的。所以可以在原文后附上它的摘要，就能保证数据的完整性。

另外，摘要算法不具有机密性，**所以真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。**

![img](/img/14.png)

## TLS 解决身份认证和不可否认

混合机密解决了数据传输的机密性，摘要算法解决了数据传输的完整性，但是无法保证通信的两个端点，**也无法保证混合加密中公钥的安全性**

为了保证通信两端的身份认证和不可否认，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。

CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”（Certificate）。

**CA 证书用来保证服务器（或客户端）的身份以及公钥的安全性**

::: tip CA 机构

知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let’s Encrypt 等，它们签发的证书分 DV、OV、EV 三种，区别在于可信程度。

DV 是最低的，只是域名级别的可信，背后是谁不知道。EV 是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份（在浏览器地址栏会显示出公司的名字，例如 Apple、GitHub 的网站）。

:::

证书的流程如下：

![image-20211110092220462](/img/16.png)

### 证书链

这还是信任链的问题。小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是 Root CA，就只能自己证明自己了，这个就叫“自签名证书”（Self-Signed Certificate）或者“根证书”（Root Certificate）。你必须相信，否则整个证书信任链就走不下去了。

有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。

![img](/img/15.png)

### 自签名证书

如果使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。

独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书。

浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。

**但你只要把它安装进系统的根证书存储区里，让它作为信任链的根，就不会再有危险警告。(相当于手动条件一个根证书？）**

## 参考

- [极客-对称加密与非对称加密](https://time.geekbang.org/column/article/109062)
- [极客-数字签名与证书](https://time.geekbang.org/column/article/109503)
