---
title: HTTP 连接管理
date: 2021-10-21 15:00:00
permalink: /http/connection
categories: 
  - 其他
  - HTTP
tags: 
  - null
---
# 连接管理

HTTP 底层借助 TCP/IP 进行数据传输, 在 HTTP/1.1 之前默认为短连接, HTTP/1.1 默认为长连接

::: warning 注意

短连接和长连接的说法是 HTTP 层面上的, 并不是 TCP/IP 的特性, TCP 连接一般不会主动关闭的

:::

## 短连接

在 HTTP/0.9、HTTP/1.0 时代, 每次 HTTP 请求前需要先与服务器建立连接, 收到响应报文后会立即关闭连接

短连接每次 HTTP 请求都要经历三次握手(1.5 RTT)建立连接, 四次挥手(2 RTT)断开连接

![img](/img/04.png)

## 长连接

在 HTTP/1.1 协议之后, HTTP 请求默认为长连接(也称为持久连接), 也就是在一个 HTTP 请求之后, 不会关闭 TCP 连接, 继续复用 TCP 连接通信

**浏览器默认为每个域名启用 6~8	 个 TCP 连接, 启用 TCP 连接是需要内存的, 不能无限制**

**TCP 协议还有 "慢启动", "拥塞窗口"等特性, 所以打开了一段时间的"热连接"更快**

**长连接还有一个重要问题就是如何区分多个报文的开始和结束, 所以最好使用 "Content-Length" 头明确响应实体的长度, 标记报文结束. 如果是流式传输, body 长度不能立即确定, 就爱使用分块传输编码**

![img](/img/05.png)

## 头部字段配置

HTTP/1.1 默认为长连接, 也可以通过 `Connection: keep-alive` 开启长连接, 通过 `Connection: close` 关闭长连接, 当客户端或服务端设置了 `Connection: close` 后, 另一方就会在 HTTP 请求结束后关闭连接.

长连接也有一些小缺点, TCP 连接长时间不关闭, 就需要内存存储 TCP 的状态(套接字). 所以也要有合适的时机关闭 TCP 连接

::: tip 提示

在 ng 服务器上, 可以设置:

1. 使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。
2. 使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。

:::

## 队头阻塞

HTTP 规定报文是"一发一收", 只有在上一个请求结束后才能进行下一请求, 如果上一个请求没有结束的话, 后续请求就要一直等待了, 就会造成队头阻塞

请求遵循着先进先出的队列, 从队列讲(因为在解析 HTML 时会优先请求一些资源, 但如果入了 HTTP 请求队列的话), 是没有优先级区分的.

![img](/img/06.png)

::: tip 注意

HTTP/1.1 的队头阻塞是针对 HTTP 协议层面的

而在 HTTP/2.0 的队头阻塞是针对 TCP 协议层面的

:::

## 性能优化

1. 浏览器会为每个域名开启 6~8 个 TCP 连接 
2. 域名分片: 浏览器会以域名限制 TCP 连接, 那么可以对同一服务器多增加几个域名
   在 HTTP/2.0 中, 域名分片甚至会影响性能. 目前最近不好使用这一过时的技术, 升级到 HTTP/2.0 即可.

## 管道化连接(pipeline)

在 HTTP/1.1 中定义了管道化连接的概念, 即可以并发多个请求, 具体如下图所示: 

![img](/img/07.png)

但是主要有两个限制:

1. 客户端必须一个请求完整交付到 tcp 缓冲区之后才能交付下一个；服务端响应也是一样。

   HTTP 是一个文本协议, 需要根据数据特定的格式来判断报文的开始和结束, 这样就需要一个请求完整交付到 TCP 传输(TCP 乱序发顺序接), 才能保证数据的完整

2. 响应的时候必须按请求的顺序发送响应

   HTTP 请求之间是没有标示的, 在响应的时候要按照请求的顺序响应, 不能客户端不能判断响应的报文属于哪个请求的响应

由于这些限制, 大多数浏览器都抛弃了管道化的尝试, 在 ios 中有所尝试

[参考-知乎问题](https://www.zhihu.com/question/340651010)

