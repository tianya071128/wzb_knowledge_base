# 渲染流程

渲染流程过于复杂，所以渲染模块将执行过程分为很多子阶段，输入的 HTML 数据经过这些子阶段，最后输出像素。这一过程叫做**渲染流水线**，其大致流程如下图：

![img](/img/102.png)

按照渲染的顺序，可分为如下几个阶段：**构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成**。每个阶段重点关注以下三个内容：

- 开始每个子阶段都有其**输入内容**；
- 然后每个子阶段有其**处理过程**；
- 最终每个子阶段会生成**输出内容**。

## 构建 DOM 树

浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为可理解的结构 —— DOM 树。

- 输入内容：非常简单的 HTML 文件

- 处理过程：由 HTML 解析器解析，**注意的是这个会解析出所有的 HTML 结构，包含了可见和不可见的元素的**

- 输出内容：树状结构的 DOM，是保存在**内存中树状数据结构**，在 js 中可通过 `document` 访问

![img](/img/103.png)

## 样式计算（Recalculate Style）

样式计算是为了计算出 DOM 节点中每个元素的具体样式：

- 输入内容：CSS 的来源主要有以下三个：

  - 通过 link 引用的外部 CSS 文件
  - 通过 link 引用的外部 CSS 文件
  - 元素的 style 属性内嵌的 CSS

- 处理过程：大体分为以下三步完成：

  - 将 CSS 转换为浏览器可以理解的结构 —— `styleSheets`，在 js 中可通过 `document.styleSheets` 访问

  - 转换样式表中的属性值，使其标准化。需要将所有值(如 2em、blue、bold)转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

    ![img](/img/104.png)

  - 根据 CSS 的继承规则和层叠规则计算 DOM 树中每个节点的样式属性

- 输出内容：每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。

![image-20220517105907083](/img/105.png)

## 布局阶段 -构建布局树(LayoutTree)

接下来需要**计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。**

- 输入内容：DOM 树 和 DOM 样式结构树(ComputedStyle)
- 处理过程：主要有两个任务，**创建布局树和布局计算**。
  - 创建布局树：DOM 中含有很多不可见的元素(head 标签、display:none 属性的元素等)，所以**需要构建一棵只包含可见元素布局树(DOM 树中所有不可见的节点都没有包含到布局树中)**。在构建布局树过程中浏览器大致完成了如下工作：
    - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；
    - 不可见的节点会被布局树忽略掉，如 head 标签、display:none 属性的元素等
  - 布局计算：根据布局树，计算布局树节点的坐标位置了，**把布局运算的结果重新写回布局树中**。
- 输出内容：布局树 -- **节点坐标位置以及边界框大小等信息**

![img](/img/106.png)

## 分层 - 构建图层树(LayerTree)

页面中有些复杂的效果(如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等)，为了实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树**。

- 输入内容：布局阶段生成的布局树。
- 处理过程：浏览器页面会被分成很多图层，这些图层叠加后合成了最终的页面。通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。**但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。**
- 输出内容：图层树(LayerTree)

![img](/img/107.png)

::: tip 什么条件会创建图层

在 [极客时间-渲染流程](https://time.geekbang.org/column/article/118826) 这篇文章中的条件存在错误(也可能是浏览器更新的问题)，目前而言，浏览器会更智能的创建图层。

- 拥有层叠上下文的条件，并且满足一定条件(这个条件暂不得知，应该是位置会发生变化时)
  - 例如固定定位(`position: fixed;`)时，触发一定条件
  - 例如发生动画时
  - 。。。
- 节点可滚动时(`overflow`)，即存在滚动条，并且还需要满足一定条件(测试存在背景颜色时)，会生成单独图层
- 指定 `will-change` 属性告知浏览器这个节点需要生成单独图层

[这个链接有一些会生成图层的例子](/html/layers.html){target="blank"}，打开 `devtools` 的 `layers(图层)` 选项卡可查看

:::

## 绘制(Paint) - 图层绘制列表

完成图层树的构建之后，渲染引擎会**对图层树中的每个图层进行绘制**：

- 输入内容：图层树(LayerTree)
- 处理过程：渲染引擎实现图层的绘制，会把每一个图层绘制拆分成很多小的**绘制指令**，在把这些指令按照顺序组成一个**待绘制列表**。绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。**绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。**
- 输出内容：就是这些每个**待绘制列表** —— **绘制列表只是用来记录绘制顺序和绘制指令的列表**

![img](/img/108.png)

::: tip 查看图层的绘制列表

可以打开“开发者工具”的“Layers”标签，选择图层，双击图层即可出现一个 `Profiler(分析器)` 标签，下图的区域 1 就是图层的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。

![img](/img/109.png)

:::

## 光栅化(raster) - 实际图层绘制

绘制列表只是用来记录绘制顺序和绘制指令的列表，而**实际上绘制操作是由渲染引擎中的合成线程**来完成的，当图层的绘制列表准备好后，主线程会把该绘制列表提交（commit）给合成线程：

![img](/img/110.png)

### 分块 - 将图层划分为图块(tile)

通常一个页面很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。通过视口，用户只能看到页面的一部分，就没有必要一次性绘制出所有图层内容。

基于这个原因，**合成线程会将图层划分为图块（tile）**，这些图块的大小通常是 256x256 或者 512x512，如下图所示：

![img](/img/111.png)

**然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化线程来执行的**。

### 光栅化 - 将图块转换为位图

光栅化就是**将图块转换为位图**。合成线程将图层划分为图块后，**会将图块发送到光栅化线程进行光栅化**。渲染进程维护了一个**光栅化线程池**，所有的图块光栅化都是在线程池内执行的。通常，光栅化过程都会**使用 GPU 来加速生成**，使用 GPU 生成位图的过程叫快速光栅化，或者 GPU 光栅化。

光栅化操作绘制出图块后(多个光栅化线程并行处理的)，并将它们存储在 GPU 内存中。

![image-20220518154946605](/img/112.png)

## 合成 - 收集图块信息创建 Compositor frame

光栅化线程会将称为 `Draw quads` 的图块信息返回给合成线程，合成线程收集这些 `Draw quads` 图块信息创建出 `Compositor frame`，然后通过 `IPC` 将其传递给浏览器进程

| 名词             | 描述                                                                         |
| ---------------- | ---------------------------------------------------------------------------- |
| Draw quads       | 考虑到页面合成，包含诸如图块在内存中的位置以及在页面中绘制图块的位置等信息。 |
| Compositor frame | 代表页面框架的绘制四边形集合。                                               |

## 显示

合成线程生成的 `Compositor frame` 提交给浏览器进程，其他渲染进程都可能把自己生成的 `compositor frame`发给 GPU 进程。

GPU 进程的 viz 线程里跑着一个 display 合成器，负责合成从不同进程发过来的 `compositor frame`。最后是 GPU 进程中的 viz 线程调用 OpenGL 的 API 把 compositor frame 绘制到屏幕上的。

![composit](/img/113.png)

## 渲染流水线总结

整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示：

1. 构建 DOM 树：渲染进程将 HTML 内容转换为能够读懂的 **DOM 树**结构。
2. 样式计算：渲染引擎将 CSS 样式表转化为浏览器可以理解的 **styleSheets**，计算出 DOM 节点的样式。
3. **布局**：创建**布局树**，并计算元素的布局信息 -- 布局阶段任务艰巨，即使是最简单的页面布局，比如从上到下的块流，也必须考虑字体有多大以及在哪里换行，因为这些会影响段落的大小和形状；然后影响下一段需要的位置。
4. 分层：对布局树进行分层，并生成**图层树**。
5. 绘制：为每个图层生成**绘制列表**，并将其提交到合成线程。
6. 光栅化：合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成：合成线程收集这些 `Draw quads` 图块信息创建出 `Compositor frame`，并通过 `IPC` 传递给浏览器进程。
8. 显示：浏览器进程将 `Draw quads` 发送给 `GUP`，由 `GPU` 显示在屏幕上

## 参考

- [Chrome - 深入了解现代网络浏览器](https://developer.chrome.com/blog/inside-browser-part3/)
- [youtube - 浏览器](https://www.youtube.com/watch?v=m-J-tbAlFic)
- [极客-渲染流程上](https://time.geekbang.org/column/article/118205)
- [极客-渲染流程下](https://time.geekbang.org/column/article/118826)
