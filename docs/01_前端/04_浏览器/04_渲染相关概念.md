# 渲染流程 - 概念

以下是一些跟渲染流水线相关的概念或问题

## 重排 - 更新了元素的几何属性

通过 `JavaScript` 或者 `CSS` 修改元素的**几何位置属性**，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫**重排**。

**重排需要更新完整的渲染流水线，所以开销也是最大的。**

![img](/img/114.png)

::: tip 通过性能面板观察重排

打开这个[html](/html/重排和重绘.html){target="blank"}，点击按钮触发重排，通过性能面板可以看到重排的过程，如下图：

![image-20220520095359664](/img/115.png)

**注意：如果直接操作 DOM 的话，例如：`dom.style.height = '300px'` 的话，是不会重新构建 DOM 树的，但是通过 `dom.innerHTML = ...` 的话，就会重新构建 DOM 树(解析 HTML)**

:::

## 重绘 - 更新元素的绘制属性

通过 `JavaScript` 或者 `CSS` 修改元素的**绘制属性**，例如改变元素的背景颜色等。那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫**重绘**。

相较于重排操作，**重绘省去了布局阶段，布局阶段是非常复杂的，所以执行效率会比重排操作要高一些**。

**注意：在极客时间课程中，重绘同时省去了分层阶段(更新图层树)，但是在性能面板中，还是会触发分层阶段的。**

![image-20220520105313051](/img/116.png)

::: tip 通过性能面板观察重绘

打开这个[html](/html/重排和重绘.html){target="blank"}，点击按钮触发重排，通过性能面板可以看到重绘的过程，如下图：

![image-20220520102454904](/img/117.png)

:::

## 分层和合成

### 帧 VS 帧率

帧：渲染流水线生成的每一副图片称为一帧

帧率：渲染流水线每秒更新了多少帧称为帧率(FPS)

一般设备屏幕刷新率是 60 次 / 秒，所以要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。也就是说，**渲染流水线的帧率不要慢于屏幕的刷新率**

如果渲染流水线每帧的生成时间太久，就会造成动画卡顿问题。Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。**分层和合成机制代表了当今最先进的渲染技术**

### 渲染流水线如何生成一帧图像？

渲染流水线生成一帧图像的方式有如下三种：**重排、重绘和合成**。

这三种方式触发的渲染路径是不一同的，**通常渲染路径越长，生成图像花费的时间就越多**：

- 重排：整个渲染流水线的每个阶段都执行一遍(构建 DOM 树可能不执行)

- 重绘：不需要布局阶段，比重排效率要高一些

- 合成：不需要触发布局、分层(构建图层树)、绘制几个阶段，如果采用了 GPU，那么合成的效率会非常高。

### 合成技术 —— 分层、分块和合成。

Chrome 中的合成技术，主要由三块组成 —— **分层、分块和合成**。

可以把一张网页想象由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。

将素材分解为多个图层的操作就称为**分层**，最后将这些图层合并到一起的操作就称为**合成**。

这样的话，当其中某个图层需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变操作时，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。

#### 分层

在渲染流程中，**[分层体现在生成布局树之后](/browser/render#分层-构建图层树-layertree)**，渲染引擎会根据布局树的特点将其转换为图层树（Layer Tree），**图层树中的每个节点都对应着一个图层**，图层树是渲染流水线后续流程的基础结构。

::: warning 图层过多的问题

每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存

:::

#### 合成

在渲染流程中，通过[绘制阶段](/browser/render#绘制-paint-图层绘制列表)会根据图层树的每一个图层生成绘制列表，在[光栅化阶段](/browser/render#光栅化-raster-实际图层绘制)根据这些绘制列表生成图片，**合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区**。

::: warning 注意

**合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的**。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

:::

#### 分块

如果说分层是从宏观上提升了渲染效率，那么分块则是**从微观层面提升了渲染效率**。

通常页面比屏幕大的多，初次渲染时没有必要等到所有的图层都光栅化后显示在屏幕上。因此，合成线程会将**每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块**，这样就可以大大加速页面的显示速度。

不过因为设计到**纹理上传** —— 从计算机内存上传到 GPU 内存的操作会比较慢，所以 Chrome 还采用了一个策略 —— **在首次合成图块的时候使用一个低分辨率的图片**。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。

### 合成 - 触发合成条件

**触发合成的方式是整个图层的几何变换，透明度变换，阴影等，这些变换都不会影响到图层的内容**。

如果文字信息的改变，布局的改变，颜色的改变等内容变化就要牵涉到重排或者重绘了。

比如滚动页面的时候，整个页面内容没有变化，这时候做的其实是对图层做上下移动，这种操作直接在合成线程里面就可以完成了。

### 合成 - 优化页面

当需要对某个元素做几何形状变换、透明度变换或者一些缩放操作时，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。

此时可以使用 `will-change` 属性来主动告诉渲染引擎将这个元素单独设置为图层，当对这个元素进行变换时，**渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率**。

**注意：`will-change` 属性只有在指定特定属性(例如：`opacity`、`transform`)时才会单独设置为图层，因为这些属性的变化才不会触发重排或重绘，可以直接在合成线程上渲染，从而启用 GPU 加速**

::: tip 通过性能面板观察重绘

打开这个[html](/html/合成.html){target="blank"}，点击按钮触发动画，通过性能面板可以看到重绘的过程，如下图：

![image-20220520152907612](/img/119.png)

可以看到，合成会跳过布局、绘制、光栅化(因为不需要重新生成图层位图)操作，此时效率是很高的

:::

## DOM 树

### DOM 是什么？

渲染引擎无法理解 HTML 文件字节流，所以要将其转化为渲染引擎能够理解的内部结构。在渲染引擎中，DOM 有三个层面的作用：

- 从页面的视角来看，DOM 是生成页面的基础数据结构。
- 从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。
- 从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。

简言之，DOM 是**表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容**。

### DOM 树如何生成?

在渲染引擎内部，DOM 树由 **HTML 解析器(HTMLParser)** 的模块生成，它的职责就是负责将 HTML 字节流转换为 DOM 结构。

**网络进程加载了多少数据，HTML 解析器便解析多少数据：**网络进程接收到响应头后，就会根据 `content-type` 判断文件的类型，如果是 HTML 类型的文件(`Content-Type: text/html` )，浏览器就会为该请求选择或者创建一个渲染进程。之后**网络进程和渲染进程就会建立一个数据通道**，网络进程下载了多少数据就通过这个通道传递给渲染进程，同时渲染进程通过 HTML 解析器将其解析为 DOM。

网络传输的是字节流的形式，转换为 DOM 需要经过三个阶段，[具体参考](https://time.geekbang.org/column/article/140140)：

![img](/img/120.png)

### JavaScript 阻塞 DOM 生成

- 内嵌脚本：当 `HTML` 解析器解析到 `<script>` 脚本标签时，就会暂停 `HTML` 的解析，因为**接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构**。

- 外链脚本：**最新浏览器版本下，会先渲染已经解析好的 DOM 树**。等到脚本下载执行的时候通过触发 重绘或重排 来重新渲染

::: warning 预解析操作

**预解析操作**：当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，**预解析线程会提前下载这些文件**。

:::

### 为什么最好将脚本文件放在最下面？

1. 放在 `<body>` 之后的话，此时 DOM 树已经解析完毕，`javascript` 直接操作 DOM 是没有问题的
2. 放在 `<body>` 之后的话，**`JavaScript` 脚本不会阻塞页面的渲染**：因为只要 DOM 树解析完成，渲染流水线就会继续执行后续流程，就会绘制一帧显示到屏幕上

::: warning 注意注意注意注意

最新版本浏览器渲染流程似乎又有差异，**当遇到脚本时，还是会阻塞 DOM 树的生成，但是会继续渲染页面。只是只渲染已经解析好的 DOM 树**

:::

::: tip 提示

所以有时需要改善用户体验时，可以在 html 文件中加入一个骨架屏之类的，让页面显示一些内容出来，而不至于长时间白屏

:::

## CSSOM - document.styleSheets

1. DOM 树 和 `CSSOM` 是串行解析的，先解析 DOM 树，后解析样式表。都是在渲染进程的主线程上进行解析

2. 内嵌样式表(`<style>`标签)：会在 `解析 HTML` 后进行解析

3. 外链样式表(`<link>` 引入)：会阻塞页面渲染。需要等到样式表下载完成后，进行样式计算，所以会阻塞初次页面渲染 -- **注意这一点，当引入样式表太大导致加载时间过长的话，页面白屏时间会过长**

   ![image-20220523173125734](/img/121.png)

4. 动态样式表(通过脚本动态创建样式表引入)：不会阻塞页面初次渲染。在样式表下载完成后触发重排或重绘进行页面更新

## 参考

- [极客 - DOM 树](https://time.geekbang.org/column/article/140140)
