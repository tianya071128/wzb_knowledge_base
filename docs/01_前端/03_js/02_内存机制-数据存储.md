# 内存机制-数据是如何存储的

## 内存模型

JS 的内存模型主要如下：

![img](/img/23.png)

在 JS 的运行过程中，主要是如上三种内存空间：

- 代码空间：存储可执行代码的。
- 栈空间
- 堆空间

## 栈空间和堆空间

栈空间就是用来存储执行上下文的。

::: warning 执行上下文

执行上下文(也称执行环境)主要有全局上下文和函数上下文（eval()调用内部也存在上下文，但不宜使用），变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的**变量对象**。而这个上下文中定义的所有变量和函数都存在于这个对象上。

全局上下文是最外层的上下文。在浏览器中，全局上下文就是我们常说的 window 对象。**上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。**

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上（**调用栈，存储在栈空间**）。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。

::: warning 作用域链

上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。

:::

```js
function foo() {
  var a = '极客时间';
  var b = a;
  var c = { name: '极客时间' };
  var d = c;
}
foo();
```

JS 在执行一段代码时，需要先进行编译创建执行上下文，然后在按照顺序执行代码。

上面当 JS 执行到第 3 行代码时，调用栈的状态如下：

![img](/img/24.png)

函数 foo 中定义的变量 a 和 b 都存储在 foo 函数的执行上下文中，而 foo 函数的执行上下文又被压入到栈中，所以**变量 a 和 b 也可以看成存储在栈中的**

当继续执行第 4 行代码 `var c = {name:"极客时间"}` 时，JS 引擎发现存储数据是一个复杂类型，并不是直接存储在 foo 函数的执行上下文中，而是分配到堆空间中，分配后该对象会有一个在堆中的地址，然后将该地址写入到栈中 c 变量里：

![img](/img/25.png)

**综上所示：原始数据类型是直接保存在”栈“空间的，而复杂(引用)类型则是存放在”堆“空间的**

::: danger 严重问题

一般说法都是如上说法，但是实际上却不是如此。例如假设字符串存储了 500MiB 大小，而 V8 默认的栈区大小为 984KiB，也就无法存放到栈中。

详情见 [知乎-JavaScript 中变量存储在堆中还是栈中？](https://www.zhihu.com/question/482433315/answer/2083349992)

:::

## 为什么需要区分栈空间和堆空间？

因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。

比如上述示例中的 foo 函数执行完毕后，要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收。

![img](/img/26.png)

- 栈空间：空间不会很大，主要用于存放一些原始类型的小数据，用于快速切换上下文，保证速度。
- 堆空间：占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

## 从内存模型角度查看闭包

```js
function foo() {
  var myName = '极客时间';
  let test1 = 1;
  const test2 = 2;
  var innerBar = {
    setName: function (newName) {
      myName = newName;
    },
    getName: function () {
      console.log(test1);
      return myName;
    },
  };
  return innerBar;
}
var bar = foo();
bar.setName('极客邦');
bar.getName();
console.log(bar.getName());
```

通过内存模型角度分析上述代码的执行流程：

1. 当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。

2. 在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。

   ::: tip 提示

   在旧版 js 引擎中，似乎不会对内部函数进行扫描，而是当发现存在闭包函数时，直接将函数的变量全部存储起来，而不是像现在这样会清理多余变量

   :::

3. 接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。

4. 由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。

5. 当 `return innerBar` ，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用，也就不会被销毁

![img](/img/27.png)

**从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用 bar.setName 或者 bar.getName 时，创建的执行上下文中就包含了“clourse(foo)”。**

**总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。**

## 参考

[极客-栈空间和堆空间：数据是如何存储的？](https://time.geekbang.org/column/article/129596)

这里最后的问题很有意思，其中有一个问题：

::: tip 问题描述

1、从内存模型角度分析执行代码的执行流程第二步看，在堆空间创建 closure(foo)对象，它是存储在 foo 函数的执行上下文中的。
那么 closure(foo)创建开始时是空对象，执行第三步的时候，才会逐渐把变量添加到其中。
2、当 foo 函数执行结束后，foo 的执行上下文是不是销毁了？如果销毁了，产生一下两个疑问：
a、如果 foo 函数执行上下文销毁了，closure(foo)并没有销毁，那 foo 函数执行上下文是怎么销毁的呢？就比如销毁一个盒子，盒子毁里，里面的东西应该也是毁掉的
b、既然 closure(foo)既然没有销毁，那它存储在堆中的什么地方呢？必定它所依赖的 foo 执行上下文已经不存在了

:::

::: tip 作者回复

关于 foo 函数执行上下文销毁过程：foo 函数执行结束之后，当前执行状态的指针下移到栈中的全局执行上下文的位置，foo 函数的执行上下文的那块数据就挪出来，这也就是 foo 函数执行上下文的销毁过程，这个文中有提到，你可以参考“调用栈中切换执行上下文状态“图。

第二个问题：innerBar 返回后，含有 setName 和 getName 对象，这两个对象里面包含了堆中的 closure(foo)的引用。虽然 foo 执行上下文销毁了，foo 函数中的对 closure(foo)的引用也断开了，但是 setName 和 getName 里面又重新建立起来了对 closure(foo)引用。

你可以：
1:打开“开发者工具”
2:在控制台执行上述代码
3:然后选择“Memory”标签，点击"take snapshot" 获取 V8 的堆内存快照。
4:然后“command+f"(mac) 或者 "ctrl+f"(win),搜索“setName”，然后你就会发现 setName 对象下面包含了 raw_outer_scope_info_or_feedback_metadata，对闭包的引用数据就在这里面。

:::

还有一个问题：

::: tip 问题描述

老师，第二遍看时有了个疑问 字符串存在栈里，但是字符串与其他原始类型不同，不一定只占几个字节的长度。如果字符串特别长，长到好几 M，也会存在栈里吗？

:::

针对于这个问题，可以查看一下这个链接：

[知乎-JavaScript 中变量存储在堆中还是栈中？](https://www.zhihu.com/question/482433315/answer/2083349992)
