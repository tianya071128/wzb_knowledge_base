# 函数

函数的基本使用/属性/方法可以查阅 MDN 或其他资料

JS 中的函数非常灵活，其根本原因**在于 JS 中的函数就是一种特殊的对象（JavaScript 中除了简单数据类型以外都是对象）**

函数是**一等公民**，可以将一个函数赋值给一个变量，还可以将函数作为一个参数传递给另外一个函数，甚至可以使得一个函数返回另外一个函数

## 函数调用时的内部属性

在 ES5 中，函数调用时内部存在两个特殊对象：arguments 和 this。ES6 新增了 new.target 属性。

### arguments

是一个类数组对象，包含调用函数时传入的所有参数。

**arguments 对象其实还有一个 callee 属性，是一个指向 arguments 对象所在函数的指针。**

**在严格模式下无法使用，就目前而言，基本上都会开启严格模式，这个属性不要在项目中使用了**

### this

根据调用类型，this 指向也是不同的

### caller

ES5 给函数对象上新增的属性。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null。

```js
function outer() {
  inner();
}
function inner() {
  console.log(inner.caller); // 指向 outer 函数
}
outer();
```

### new.target

ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。

如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的构造函数。

```js
function King() {
  if (!new.target) {
    throw 'King must be instantiated using "new"';
  }
  console.log('King instantiated using "new"');
}
new King(); // King instantiated using "new"
King(); // Error: King must be instantiated using "new"
```

## 函数的本质就是一个可调用的对象

函数和对象一样，可以添加属性和方法，不同的是，函数是可以被调用的。

在创建函数时，除了常规的属性和原型上的方法，还会添加几个内置的属性：

- name：函数名，如果没有提供的话，函数就是一个匿名函数（anonymous）。

  ::: tip 注意

  需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的`name`属性，会返回空字符串，而 ES6 的`name`属性会返回实际的函数名。

  [ES6 入门](https://es6.ruanyifeng.com/#docs/function#name-%E5%B1%9E%E6%80%A7)

  :::

- code：**其值表示函数代码，以字符串的形式存储在内存中。当需要调用函数时，就会从 code 中取出代码出来执行**

- [[FunctionLocation]]：表示函数定义的文件位置

- [[Scopes]]：函数的可访问作用域，包含闭包作用域

从上面的属性可以看出，其实函数也就是一个对象，只是创建函数的时候引擎会创建很多内置属性用于标识这个函数。

**在执行函数的时候，首先会根据函数环境创建执行上下文，初始化词法环境、变量环境（猜测应该是在变量环境中会存在一个指针引用着闭包作用域以及还有 arguments、实参等变量 ）、this 绑定，然后将其推入到调用栈中执行**

## 从编译角度看闭包

### 惰性解析函数

惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。

利用惰性解析可以加速 JavaScript 代码的启动速度，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间。

```js
function foo(a, b) {
  var d = 100;
  var f = 10;
  return d + f + a + b;
}
var a = 1;
var c = 4;
foo(1, 5);
```

例如上面代码，在解析过程中遇到 foo 函数时，V8 就会将这个函数声明转换为函数对象：

![img](/img/43.jpg)

代码解析完毕后，便会按照顺序自上而下执行代码，当执行到 foo 函数调用时，**过程是从 foo 函数对象中取出函数代码，然后和编译顶层代码一样，V8 会先编译 foo 函数的代码，编译时同样需要先将其编译为抽象语法树和字节码，然后再解释执行。**

### 闭包给惰性解析带来的问题

```js
function foo() {
  var d = 20;
  return function inner(a, b) {
    const c = a + b + d;
    return c;
  };
}
const f = foo();
```

上面代码中，foo 函数返回的 inner 函数中还引用了 d 变量，如果只使用惰性解析的话，那么当 foo 函数执行完后，就会将 foo 函数的执行上下文从调用栈中弹出，此时 foo 函数的执行上下文就会被销毁，但是返回的 inner 函数中还引用了 d 变量，**所以正常处理方式应该是 foo 函数的执行上下文虽然被销毁了，但是 inner 函数引用的 foo 函数中的变量却不能被销毁。**

在执行 foo 函数的阶段，虽然采取了惰性解析，不会解析和执行 foo 函数中的 inner 函数，但是 V8 还是需要判断 inner 函数是否引用了 foo 函数中的变量，**负责处理这个任务的模块叫做预解析器**。

### 预解析器解析闭包函数

V8 引入了预解析器，当解析代码遇到函数的时候，**那么预解析器会对该函数做一次快速的预解析，**主要目的有两个：

- 判断函数是否有语法上的错误
- 检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。**这个引用就是内部属性 [[Scopes]]**

只要在函数代码解析中遇到了函数，预解析器就会对其预解析，而不是在返回这个函数时解析的。**因为闭包广义概念就是在函数中定义的函数**，如下图：

![image-20211124105736329](/img/44.png)

::: tip eval 函数下的闭包

请慎用 eval 函数，因为使用 eval 函数时，只有在执行的时候才能确定函数引用变量的情况，此时预解析器就无法解析闭包引用的变量，**那么当遇到闭包时，就会将闭包函数的外部函数所有的作用域链都引用进来**

:::

## 参考

- [极客-函数即对象](https://time.geekbang.org/column/article/212123)
- [极客-V8 是如何实现闭包的？](https://time.geekbang.org/column/article/223168)
