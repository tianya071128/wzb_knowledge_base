# JS 执行机制-执行上下文

执行上下文是 JS 执行一段代码时的运行环境，也可称为“执行环境”。

当一段代码被执行时，JS 引擎先会对其进行编译，并创建执行上下文推入到调用栈的栈顶。

## 执行上下文的类型

一般来说，以下三种情况会创建执行上下文：

- 全局执行上下文：JS 引擎在执行全局代码时，会先编译全局代码并创建全局执行上下文，而且在整个页面生命周期，只会存在一份并且一直在调用栈的栈底。
- 函数执行上下文：在函数定义时，不会进行代码的编译，但是**在函数调用时，就会对函数体代码进行编译并创建函数的执行上下文**，推入到调用栈的栈顶，当函数执行结束时，函数上下文从栈顶弹出，[然后会被销毁](/js/recovery#栈空间-调用栈-的垃圾回收)。
- eval 函数执行上下文：当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

## 执行上下文的内容

执行上下文在 ES3 和 ES5 中有一些区别

### ES3 执行上下文

在 ES3 中，执行上下文的内容：

- 变量对象（variable object 简称 VO）

  JS 引擎会用当前函数的**参数列表**（`arguments`）初始化一个 “变量对象”，函数代码块中声明的 **变量** 和 **函数** 将作为属性添加到这个变量对象上。

  ::: warning 注意

  1. **全局上下文中的变量对象就是全局对象**，以浏览器环境来说，就是 `window` 对象。
  2. **函数执行上下文中的变量对象内部定义的属性**，是不能被直接访问的，只有当函数被调用时，变量对象（`VO`）被激活为活动对象（`AO`）时，我们才能访问到其中的属性和方法。

  ![变量对象的创建细节](/img/45.png)

  :::

- 活动对象（activation object 简称 AO）

  函数进入执行阶段时，原本不能访问的变量对象被激活成为一个活动对象，自此，我们可以访问到其中的各种属性。

  ::: warning 注意

  其实变量对象和活动对象是一个东西，只不过处于不同的状态和阶段而已。

  :::

- 作用域链（scope chain）

  规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。**函数在创建时，函数对象上就会生成一个 `[[Scopes]]` 内部属性，当函数执行时，会创建一个执行环境，然后通过复制函数的 `[[scope]]` 属性中的对象构建起执行环境的作用域链，然后，变量对象 `VO` 被激活生成 `AO` 并添加到作用域链的前端，完整作用域链创建完成**

- this

ES3 的执行上下文用代码表示类似于如下：

```js
executionContext：{
    [variable object | activation object]：{
        arguments,
        variables: [...],
        funcions: [...]
    },
    scope chain: variable object + all parents scopes
    thisValue: context object
}
```

### ES5 执行上下文

ES5 的执行上下文做了部分调整，最主要的是去除了变量对象和活动对象，以 **词法环境组件（** **`LexicalEnvironment component`）** 和 **变量环境组件（** **`VariableEnvironment component`）** 替代。

以代码模拟如下：

```js
ExecutionContext = {
  ThisBinding = <this value>, // this
  LexicalEnvironment = { ... }, // 词法环境 - 包含着作用域组件
  VariableEnvironment = { ... }, // 变量环境
}
```

- **词法环境组件（** **`LexicalEnvironment component`）**

  [ES6 官方](https://link.juejin.cn/?target=http%3A%2F%2Fecma-international.org%2Fecma-262%2F6.0%2F) 中的词法环境定义：

  > 词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。

  可以简单理解为 ES3 中的变量对象和作用域链的

- 变量环境

  **变量环境** 也是一个 **词法环境**，与词法环境不同的是前者是被用来存储函数声明和变量（`let` 和 `const`）绑定，而后者只用来存储 `var` 变量绑定。

上面详细可见：[掘金-文章](https://juejin.cn/post/6844903682283143181#heading-7)

## 执行上下文的生命周期

主要经历三个阶段：创建阶段、执行阶段、销毁阶段。

对于 `ES5` 中的执行上下文（ES3 类似），我们可以用下面这个列表来概括程序执行的整个过程：

1. 程序启动，全局上下文被创建
   1. 创建全局上下文的 **词法环境**
      1. 创建 **对象环境记录器** ，它用来定义出现在 **全局上下文** 中的变量和函数的关系（负责处理 `let` 和 `const` 定义的变量）
      2. 创建 **外部环境引用**，值为 **`null`**
   2. 创建全局上下文的 **变量环境**
      1. 创建 **对象环境记录器**，它持有 **变量声明语句** 在执行上下文中创建的绑定关系（负责处理 `var` 定义的变量，初始值为 `undefined` 造成声明提升）
      2. 创建 **外部环境引用**，值为 **`null`**
   3. 确定 `this` 值为全局对象（以浏览器为例，就是 `window` ）
2. 函数被调用，函数上下文被创建
   1. 创建函数上下文的 **词法环境**
      1. 创建 **声明式环境记录器** ，存储变量、函数和参数，它包含了一个传递给函数的 **`arguments`** 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。（负责处理 `let` 和 `const` 定义的变量）
      2. 创建 **外部环境引用**，值为全局对象，或者为父级词法环境（作用域）
   2. 创建函数上下文的 **变量环境**
      1. 创建 **声明式环境记录器** ，存储变量、函数和参数，它包含了一个传递给函数的 **`arguments`** 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。（负责处理 `var` 定义的变量，初始值为 `undefined` 造成声明提升）
      2. 创建 **外部环境引用**，值为全局对象，或者为父级词法环境（作用域）
   3. 确定 `this` 值
3. 进入函数执行上下文的执行阶段：
   1. 将执行上下文推入调用栈中
   2. 在上下文中运行/解释函数代码，并在代码逐行执行时分配变量值。
   3. 如果内部有函数调用就创建一个新的执行上下文压入执行栈并把控制权交出……
4. 函数执行完成，[会被弹出执行上下文栈并且销毁](/js/recovery#栈空间-调用栈-的垃圾回收)，控制权被重新交给执行栈上一层的执行上下文。

## 调用栈（执行上下文栈）

在存在嵌套函数调用时，就会存在多个执行上下文，JS 引擎**通过栈的数据结构来管理的**。

在执行上下文创建好后，JS 引擎会将执行上下文压入栈中，这种用来管理执行上下文的栈称为**执行上下文栈**，又称**调用栈**。

```js
var a = 2;
function add(b, c) {
  return b + c;
}
function addAll(b, c) {
  var d = 10;
  result = add(b, c);
  return a + result + d;
}
addAll(3, 6);
```

第一步：创建全局上下文，并压入栈底（如果已经存在，则不会重复创建），接着顺序执行代码。

第二步：遇到函数 addAll 调用。**当遇到函数调用时，JS 引擎会编译该函数，并为其创建一个执行上下文，将其压入调用栈栈顶**，接着顺序执行代码

第三步：当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈。当 add 函数执行完毕，就会将该函数的执行上下文从栈顶弹出，如下图所示：

![image-20211125092346199](/img/46.png)

第四步：addAll 函数执行完成后，也将 addAll 的执行上下文从栈顶弹出，此时调用栈中只剩下全局上下文了。

::: warning 注意

**调用栈是 JS 引擎追踪函数执行的一个机制，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。**

调用栈只是函数调用之间的关系，**而不是作用域链**，不要将其混为一谈

:::

### 浏览器中查看调用栈

- 可以通过断点形式查看函数的调用栈
- 通过 `console.trace()` 输出当前函数的调用栈

### 栈溢出

调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。

### 尾递归优化

尾调用之所以与其他调用不同，就在于它的特殊的调用位置。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的相关信息，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了，这样一来，运行尾递归函数时，执行栈永远只会新增一个上下文。

但是目前没有浏览器实现，[具体查看](https://juejin.cn/post/6844904158957404167#heading-19)

## 参考

- [掘金-面试官：说说执行上下文吧](https://juejin.cn/post/6844904158957404167)
- [掘金-[译] 理解 JavaScript 中的执行上下文和执行栈](https://juejin.cn/post/6844903682283143181)
- [极客-调用栈](https://time.geekbang.org/column/article/120257)
