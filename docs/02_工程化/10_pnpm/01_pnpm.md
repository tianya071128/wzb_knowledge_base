# pnpm

## pnpm 的优势

### 节省磁盘空间

![img](/img/01.svg)

使用 npm 时，依赖每次被不同的项目使用，都会重复安装一次。 而在使用 pnpm 时，依赖会被存储在内容可寻址的存储中，所以：

1. 如果你用到了某依赖项的不同版本，**只会将不同版本间有差异的文件添加到仓库**。 例如，如果某个包有 100 个文件，而它的新版本只改变了其中 1 个文件。那么 `pnpm update` 时只会向存储中额外添加 1 个新文件，而不会因为单个改变克隆整个依赖。
2. 所有文件都会存储在硬盘上的某一位置。 当软件包被被安装时，包里的文件会**硬链接**到这一位置，而不会占用额外的磁盘空间。 这允许你跨项目地共享同一版本的依赖。

因此，你在磁盘上节省了大量空间，这与项目和依赖项的数量成正比，并且安装速度要快得多！

### 提高安装速度

pnpm 分三个阶段执行安装：

1. 依赖解析。 仓库中没有的依赖都被识别并获取到仓库。
2. 目录结构计算。 `node_modules` 目录结构是根据依赖计算出来的。
3. 链接依赖项。 所有以前安装过的依赖项都会直接从存储区中获取并链接到 `node_modules`。

![img](/img/02.svg)

这种方法比传统的三阶段安装过程（解析、获取和写入所有依赖项到 `node_modules`）要快得多。

![img](/img/03.svg)

### 创建一个非扁平的 node_modules 目录

使用 npm 或 Yarn Classic 安装依赖项时，所有的包都被提升到模块目录的根目录。 这样就导致了一个问题，源码可以直接访问和修改依赖，而不是作为只读的项目依赖。

**默认情况下，pnpm 使用符号链接将项目的直接依赖项添加到模块目录的根目录中。**

> 并不是创建了一个嵌套的目录, 而是将依赖链接到了 `node_modules/.pnpm` 中
>
> 例如 `express` 包, 其生成的 `node_modules` 如下所示
>
>  ```tex
> ▾ node_modules
>   ▾ .pnpm
>     ▸ accepts@1.3.5
>     ▸ array-flatten@1.1.1
>     ...
>     ▾ express@4.16.3
>       ▾ node_modules
>         ▸ accepts --> 链接到了 ../accepts@1.3.5
>         ...
>         ▸ etag
>         ▾ express --> 当访问 accepts 时, 访问的就是: ../accepts
>           ▸ lib
>             History.md
>             index.js
>             LICENSE
>             package.json
>             Readme.md
>    ▾ express  --> 链接到 .pnpm/express@4.16.3/node_modules/express
>     ▸ lib
>       History.md
>      index.js
>       LICENSE
>       package.json
>       Readme.md
>    ```
>    **这个平铺的结构避免了 npm v2 创建的嵌套 `node_modules` 引起的长路径问题，但与 npm v3,4,5,6 或 yarn v1 创建的平铺的 `node_modules` 不同的是，它保留了包之间的相互隔离。**

## 文件链接方式

### 硬链接

硬链接（Hard Link）是一种文件系统中的概念，**用于在同一个文件系统中创建多个指向同一个文件内容的目录项**

#### 基本原理

- **文件系统中的数据存储**：在常见的文件系统（如 Linux 的 ext4、Windows 的 NTFS 等）中，文件实际上是由两部分组成，一部分是文件的数据内容，存储在磁盘的数据块中；另一部分是文件的元数据，包含文件名、文件权限、文件的创建时间、修改时间以及指向文件数据内容所在磁盘位置的指针等信息，这些元数据通常存储在文件系统的 inode（索引节点）里。
- **硬链接的创建机制**：当创建一个硬链接时，实际上是在文件系统中创建了一个新的目录项，这个目录项与原文件共享同一个 inode，也就意味着它们指向磁盘上完全相同的文件数据内容，通过不同的文件名（或者说不同的目录路径下的文件名）来访问同一个文件实体。例如，在 Linux 系统中，使用 `ln` 命令创建硬链接，格式为 `ln 原文件路径 硬链接文件路径`，如 `ln /home/user/file.txt /home/user/link_file.txt`，这样就创建了一个名为 `link_file.txt` 的硬链接，它和 `file.txt` 指向相同的文件内容。

#### 特点

- **共享文件内容**：硬链接指向的文件内容是完全共享的，对其中一个硬链接文件进行读写操作，实际上等同于对所有硬链接指向的同一个文件内容进行操作，改动会实时反映在所有硬链接对应的文件访问中。例如，通过一个硬链接写入了新的数据，那么从另一个硬链接打开文件时，也能看到新增的数据。
- **文件属性一致**：由于共享同一个 inode，所有硬链接对应的文件的文件属性（如文件权限、所有者、所属组、时间戳等）都是相同的，并且这些属性是关联在一起的，修改其中一个硬链接文件的属性，其他硬链接对应的文件属性也会同步改变。

* **删除特性**：只有当所有指向同一个文件内容的硬链接都被删除时，文件系统才会真正删除对应的文件数据内容以及 inode 信息，释放磁盘空间。也就是说，只要存在一个硬链接，文件就依然存在于磁盘上，哪怕最初创建该文件的那个 “原始文件名” 对应的硬链接被删除了也是如此。

### 软链接(符号链接)

软链接（Symbolic Link），也被叫做符号链接，是文件系统里的一个关键概念，它为文件或目录创建了一个指向其他文件或目录的引用。

#### 基本原理

软链接本质上是一种特殊的文件，其内容为另一个文件或目录的路径。在文件系统里，软链接拥有自己独立的 inode，不过它本身并不包含实际的数据内容，只是保存了指向目标文件或目录的路径信息。当用户访问软链接时，文件系统会依据这个路径去查找并访问真正的目标文件或目录。

#### 特点

- **独立 inode**：软链接具备独立的 inode，这意味着它和目标文件或目录在文件系统中是相互独立的实体，有自己的文件属性（如权限、创建时间等）。
- **路径指向性**：软链接的核心是其保存的路径信息，文件系统依据这个路径来定位目标。**若目标文件或目录被移动、重命名或者删除，软链接就会失效，出现 “断链” 情况**。
- **跨文件系统支持**：软链接能够跨越不同的文件系统创建，只要路径有效，无论目标文件或目录处于哪个文件系统，都可以创建指向它的软链接。

### 硬软链接比对

- **存储指向不同**：软链接（符号链接）保存的是指向目标文件或目录的路径信息，类似于一个快捷方式，它有自己独立的 inode，而硬链接是直接共享目标文件的 inode。
- **文件内容关联性**：对硬链接文件的操作就是对实际文件内容的操作，而软链接文件本身只是一个指向，当访问软链接文件时，文件系统会根据其指向的路径去查找真正的目标文件，如果目标文件被移动或删除，软链接就会失效，出现 “断链” 情况；但硬链接只要还有一个存在，就始终能访问到文件内容。
- **跨文件系统表现**：硬链接只能在同一个文件系统内创建，因为它依赖于共享 inode 的机制，不同的文件系统有各自独立的 inode 管理体系；而软链接可以跨越不同的文件系统创建，它只关心所指向的目标文件路径是否有效，不受文件系统限制。
