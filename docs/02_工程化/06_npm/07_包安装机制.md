---
title: 包安装机制
date: 2021-10-21 15:00:00
permalink: /npm/install
categories: -- 工程化
  -- npm
tags:
  - null
---

# 包安装机制

包安装机制随着版本的迭代，安装机制也不断进化，以如下为例，假设项目`App`中有如下三个依赖：

```json
"dependencies": {
    A: "1.0.0",
    B: "1.0.0",
    C: "1.0.0"
}
```

`A`、`B`、`C`三个模块又有如下依赖：

```
A@1.0.0 -> D@1.0.0

B@1.0.0 -> D@2.0.0

C@1.0.0 -> D@2.0.0
```

## 嵌套安装 - npm 2.x 时代

在 `npm 2.x` 时代，安装方式简单直接：以递归的方式，按照包依赖的树形结构下载到项目的 `node_modules` 目录中。

执行`npm install`后，项目`App`的`node_modules`会变成如下目录结构：

```tex
├── node_modules
│   ├── A@1.0.0
│   │   └── node_modules
│   │   │   └── D@1.0.0
│   ├── B@1.0.0
│   │   └── node_modules
│   │   │   └── D@2.0.0
│   └── C@1.0.0
│   │   └── node_modules
│   │   │   └── D@2.0.0
```

嵌套安装的缺点：

* **会造成相同模块的大量冗余问题**

* **会造成目录结构嵌套比较深的问题**

  

## 扁平安装 - npm 3.x 时代

从 `npm 3.x` 时代开始采用扁平化的方式来安装模块：**优先将模块安装在一级`node_modules`中**。当安装到相同模块时，判断这个模块是否已安装(符合已安装模块的版本)，如果符合则跳过，不符合则在当前模块的`node_modules`下安装该模块。

此时，`APP` 安装后 `node_modules`会变成如下目录结构：

```tex
├── node_modules
│   ├── A@1.0.0
│   ├── B@1.0.0
│   │   └── node_modules
│   │   │   └── D@2.0.0 # 重复模块 - 版本不兼容
│   ├── C@1.0.0
│   │   └── node_modules
│   │   │   └── D@2.0.0 # 重复模块 - 与一级版本不兼容
│   └── D@1.0.0 
```

### 广度优先安装

当安装版本遇到相同模块但版本不兼容的时候，哪个会被优先安装在一级`node_modules`目录下呢？

**安装包的时候，首先将`package.json`里的依赖按照首字母（@排最前）进行排序，然后将排序后的依赖包按照广度优先遍历的算法进行安装，最先被安装到的模块将会被优先安装在一级`node_modules`目录下**。

> 广度优先：优先将同一层的依赖安装好，而不是优先将一个模块及其所有的子模块安装好。

如下是对结果的验证，可以看到 `semver` 安装在 `node_modules` 顶层的模块版本是不一样的：

![image-20220705104550485](/img/157.png)

![image-20220705104653414](/img/158.png)

### 已安装包情况，安装新包

**在一级`node_moudles`中已经存在依赖包的情况下，新安装的依赖包如果存在版本冲突，则会安装到新依赖包的`node_modules`中**。

![image-20220705110613544](/img/159.png)

### 减少包树中的重复

假设我们卸载了 `node_modules` 中某个顶层包的话，此时 `node_modules` 就会变成如图所示：

![image-20220705111250699](/img/160.png)

可以通过 `npm dedupe` 命令来减少包树中的重复，将依赖关系进一步向上移动来简化整体结构，从而可以更有效地由多个依赖包共享：

![image-20220705112022699](/img/161.png)

## package-lock.json - npm v5 时代

在安装包的时候，通常在 `package.json` 文件中都是只锁定大版本：`vue: ^2.5.17`，此时安装包时可能会下载 `2.6.14`，下载大版本下的最新版本。

**但是这种机制最大的问题在于**：当包的小版本存在更新时，不同开发者的版本可能不一致。

`npm v5`  引入了 `package-lock.json` 文件，精确描述了`node_modules` 目录下所有的包的树状依赖结构，每个包的版本号都是完全精确的，**用于锁定项目依赖的版本**。

* 当项目初始化安装模块时，会生成 `pckage-lock.json` 文件，用于描述项目的依赖关系以及版本
* 当协同开发者安装模块时，根据 `package-lock.json` 文件安装项目依赖，这样不同开发者的版本都一致

对于应用开发时，建议把`package-lock.json`文件提交到代码版本仓库，从而让你的团队成员、运维部署人员或`CI`系统可以在执行`npm install`时安装的依赖版本都是一致的。

对于包(公共库)开发时，则不应把`package-lock.json`文件发布到仓库中。实际上，`npm`也默认不会把`package-lock.json`文件发布出去。之所以这么做，是因为库项目一般是被其他项目依赖的，在不写死的情况下，就可以复用主项目已经加载过的包，而一旦库依赖的是精确的版本号那么可能会造成包的冗余。

## 安装流程

`npm install` 安装包的整体流程如图：

![05](/img/162.png)

* 检查 `.npmrc` 文件：优先级为：项目级的 `.npmrc` 文件 > 用户级的 `.npmrc` 文件> 全局级的 `.npmrc` 文件 > npm 内置的 `.npmrc` 文件

* 检查项目中有无 `lock` 文件。

  * 无 `lock` 文件：

    * 从 `npm` 远程仓库获取包信息

    * 根据 `package.json`构建依赖树，构建过程：

      * 构建依赖树时，不管其是直接依赖还是子依赖的依赖，优先将其放置在 `node_modules` 根目录。

      * 当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 `node_modules` 下放置该模块。

      * 注意这一步只是确定逻辑上的依赖树，并非真正的安装，后面会根据这个依赖结构去下载或拿到缓存中的依赖包

    * 在缓存中依次查找依赖树中的每个包

      * 不存在缓存：

        * 从 `npm` 远程仓库下载包

        * 校验包的完整性

          * 校验不通过：
            * 重新下载

            * 校验通过：
              * 将下载的包复制到 `npm` 缓存目录
              * 将下载的包按照依赖结构解压到 `node_modules`

      * 存在缓存：将缓存按照依赖结构解压到 `node_modules`

    * 生成 `lock` 文件

* 有 `lock` 文件：

  * 检查 `package.json` 中的依赖版本是否和 `package-lock.json` 中的依赖有冲突。
  * 如果没有冲突，直接跳过获取包信息、构建依赖树过程，开始在缓存中查找包信息，后续过程相同

## 参考

[掘金-前端工程化（5）](https://juejin.cn/post/6844903870578032647#heading-0`)







