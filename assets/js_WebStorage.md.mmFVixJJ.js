import{_ as e,c as a,o as s,aR as i}from"./chunks/framework.DLAwTCsc.js";const b=JSON.parse('{"title":"Web Storage","description":"","frontmatter":{},"headers":[],"relativePath":"js/WebStorage.md","filePath":"01_前端/03_js/16_WebStorage.md","lastUpdated":1739447932000}'),t={name:"js/WebStorage.md"},o=i(`<h1 id="web-storage" tabindex="-1">Web Storage <a class="header-anchor" href="#web-storage" aria-label="Permalink to &quot;Web Storage&quot;">​</a></h1><p>Web Storage 的目的是解决客户端存储不需要频繁发送回服务器的数据时使用 cookie 的问题。</p><p>Web Storage 主要定义了两个对象：localStorage 和 sessionStorage。localStorage 是永久存储机制，sessionStorage 是跨会话的存储机制。</p><h2 id="与-cookie-的区别" tabindex="-1">与 cookie 的区别 <a class="header-anchor" href="#与-cookie-的区别" aria-label="Permalink to &quot;与 cookie 的区别&quot;">​</a></h2><ol><li>cookie 每个 HTTP 请求都会发送到服务器，增加传输的数据。Web Storage 只会存储在客户端</li><li>cookie 存储大小很小，而 Web Storage 大小则大的多，大多数会限制为每个源 5MB。</li><li>cookie 可以被服务器通过响应请求头 <code>set-cookie</code> 操作，而 Web Storage 只能在客户端被操作</li><li>cookie 根据设置的不同可以跟域名、路径绑定。而 Web Storage 只能在同源(协议、域名、端口)绑定，不区分路径。</li></ol><h2 id="localstorage-和-sessionstorage-的区别" tabindex="-1">localStorage 和 sessionStorage 的区别 <a class="header-anchor" href="#localstorage-和-sessionstorage-的区别" aria-label="Permalink to &quot;localStorage 和 sessionStorage 的区别&quot;">​</a></h2><table><thead><tr><th><strong>localStorage</strong></th><th><strong>sessionStorage</strong></th></tr></thead><tbody><tr><td>在同源的所有标签页和窗口之间共享数据，永久存储机制</td><td>在<strong>当前浏览器标签页</strong>中可见，包括同源的 iframe</td></tr><tr><td>浏览器重启后数据仍然保留</td><td>页面刷新后数据仍然保留（但标签页关闭后数据则不再保留）</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">提示</p><p>sessionStorage 是标签页存活时存储的时候，只要在一个标签页中，即使刷新数据也不会销毁。</p></div><h2 id="数据读写" tabindex="-1">数据读写 <a class="header-anchor" href="#数据读写" aria-label="Permalink to &quot;数据读写&quot;">​</a></h2><p>localStorage 和 sessionStorage 都支持以下的方法进行读写：</p><ul><li><code>setItem(key, value)</code> —— 存储键/值对。</li><li><code>getItem(key)</code> —— 按照键获取值。</li><li><code>removeItem(key)</code> —— 删除键及其对应的值。</li><li><code>clear()</code> —— 删除所有数据。</li><li><code>key(index)</code> —— 获取该索引下的键名。</li><li><code>length</code> —— 存储的内容的长度。</li></ul><p>如上所述，它就像一个 <code>Map</code> 集合（<code>setItem/getItem/removeItem</code>），但也允许通过对象属性 <code>key(index)</code> 来按索引访问。</p><h3 id="类对象形式访问" tabindex="-1">类对象形式访问 <a class="header-anchor" href="#类对象形式访问" aria-label="Permalink to &quot;类对象形式访问&quot;">​</a></h3><p>可以通过访问对象一样访问 Web Storage，但不要这样使用：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置 key</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">localStorage.test </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取 key</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(localStorage.test); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除 key</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> localStorage.test;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>不要这样使用，不规范，并且这样操作不会触发 <code>storage</code> 事件</strong></p><h3 id="写入的数据只能是字符串" tabindex="-1">写入的数据只能是字符串 <a class="header-anchor" href="#写入的数据只能是字符串" aria-label="Permalink to &quot;写入的数据只能是字符串&quot;">​</a></h3><p>键和值必须是字符串。如果是任何其他类型，例数字或对象，它会被自动转换为字符串。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">localStorage.user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(localStorage.user); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [object Object]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="storage-事件" tabindex="-1">storage 事件 <a class="header-anchor" href="#storage-事件" aria-label="Permalink to &quot;storage 事件&quot;">​</a></h2><p>当 Web Storage 数据更新时，就会 storage 事件，对象对象中会保存如下信息：</p><ul><li><code>key</code> —— 发生更改的数据的 <code>key</code>（如果调用的是 <code>.clear()</code> 方法，则为 <code>null</code>）。</li><li><code>oldValue</code> —— 旧值（如果是新增数据，则为 <code>null</code>）。</li><li><code>newValue</code> —— 新值（如果是删除数据，则为 <code>null</code>）。</li><li><code>url</code> —— 发生数据更新的文档的 url。</li><li><code>storageArea</code> —— 发生数据更新的 <code>localStorage</code> 或 <code>sessionStorage</code> 对象。</li></ul><div class="warning custom-block"><p class="custom-block-title">注意：关于触发时机</p><p>重要的是：该事件会在所有可访问到存储对象的 <code>window</code> 对象上触发，导致当前数据改变的 <code>window</code> 对象除外。</p><p>或者说，<strong>当前页面使用的 storage 被其他页面(或者当前页面的同源 iframe)修改时会触发 storage 事件</strong>（事件在同一个域下的不同页面之间触发，即在 A 页面注册了 storge 的监听处理，只有在跟 A 同域名下的 B 页面操作 storage 对象，A 页面才会被触发 storage 事件）</p></div>`,23),l=[o];function n(r,c,d,p,h,g){return s(),a("div",null,l)}const u=e(t,[["render",n]]);export{b as __pageData,u as default};
