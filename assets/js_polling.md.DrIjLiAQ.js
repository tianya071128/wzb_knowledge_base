import{_ as e,c as t,o as a,aR as r,bN as o,bO as l}from"./chunks/framework.DLAwTCsc.js";const m=JSON.parse('{"title":"网络请求 - 轮询","description":"","frontmatter":{"title":"网络请求 - 轮询","date":"2021-10-21T15:00:00.000Z","permalink":"/js/polling","categories":["前端","JS"],"tags":[null]},"headers":[],"relativePath":"js/polling.md","filePath":"01_前端/03_js/22_轮询.md","lastUpdated":1739447932000}'),i={name:"js/polling.md"},s=r('<h1 id="轮询" tabindex="-1">轮询 <a class="header-anchor" href="#轮询" aria-label="Permalink to &quot;轮询&quot;">​</a></h1><p>轮询也是使用 HTTP 协议进行的，是客户端持续的向服务端发起请求。</p><h2 id="短轮询-常规轮询" tabindex="-1">短轮询(常规轮询) <a class="header-anchor" href="#短轮询-常规轮询" aria-label="Permalink to &quot;短轮询(常规轮询)&quot;">​</a></h2><p>从服务器获取最新消息最简单的方式就是定期轮询。浏览器定期向服务器发送请求(例如，每 10 秒一次)，时间线如图：</p><p><img src="'+o+'" alt="image-20211222163920010" loading="lazy"></p><p>这样虽然可行，但是存在如下缺点：</p><ul><li>两个请求之间的时间不好把握，太长的话消息更新不及时，太短的话耗费性能</li><li>即使没有消息，服务器也会每隔一段时间被请求轰炸一次</li></ul><h2 id="长轮询" tabindex="-1">长轮询 <a class="header-anchor" href="#长轮询" aria-label="Permalink to &quot;长轮询&quot;">​</a></h2><p>长轮询针对短轮询的缺点改进了一番，把短轮询颠倒了一下，流程如下：</p><ol><li>请求发送到服务器。</li><li>服务器在有消息之前不会关闭连接。</li><li>当消息出现时 —— 服务器将对其请求作出响应。</li><li>浏览器立即发出一个新的请求。</li></ol><p><img src="'+l+'" alt="image-20211222164523032" loading="lazy"></p><h2 id="http-流" tabindex="-1">HTTP 流 <a class="header-anchor" href="#http-流" aria-label="Permalink to &quot;HTTP 流&quot;">​</a></h2><p>在 <code>js 高程第三版-P588</code> 中描述的一种实现持久连接的方法</p><p>流不同于上述轮询方式，因为在页面的生命周期内只使用一个 HTTP 连接。也就是在浏览器发起一个 HTTP 请求，服务器一直挂起，周期性的向客户端发送消息。</p><p>而客户端通过在 <code>readystatechange</code> 事件中响应数据，就可以对 responseText 进行分割以取得最新数据。</p><p>虽然这种方式一定程度上可行，但管理起来很是麻烦并且容易出错，并且在<strong>IE 浏览器存在兼容性</strong>。SSE（Server-Sent Events，IE 也不支持）是对这一方式的封装。</p><h2 id="sse" tabindex="-1">SSE <a class="header-anchor" href="#sse" aria-label="Permalink to &quot;SSE&quot;">​</a></h2><p>Server Sent Events 它能保持与服务器的持久连接，并从中接收事件(数据)。其原理就是保持一个 HTTP 的连接服务器按照特定格式发送消息。</p><h3 id="与-websocket-的区别" tabindex="-1">与 WebSocket 的区别 <a class="header-anchor" href="#与-websocket-的区别" aria-label="Permalink to &quot;与 WebSocket 的区别&quot;">​</a></h3><table><thead><tr><th><code>WebSocket</code></th><th><code>EventSource</code></th></tr></thead><tbody><tr><td>双向：客户端和服务端都能交换消息</td><td>单向：仅服务端能发送消息</td></tr><tr><td>二进制和文本数据</td><td>仅文本数据</td></tr><tr><td>WebSocket 协议</td><td>常规 HTTP 协议</td></tr></tbody></table><p>SSE 的优点在于简单，基于 HTTP 协议，并且支持自动重新连接。缺点在于只能传递文本数据，并且<strong>IE 不兼容</strong>。</p><h3 id="具体实现" tabindex="-1">具体实现 <a class="header-anchor" href="#具体实现" aria-label="Permalink to &quot;具体实现&quot;">​</a></h3><p>SSE 在项目中很少需要，具体实现参考：<a href="https://zh.javascript.info/server-sent-events" target="_blank" rel="noreferrer">JS教程-Server Sent Events</a></p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://zh.javascript.info/long-polling" target="_blank" rel="noreferrer">JS 教程 - 轮询</a></li><li>JS 高程第三版 P588</li></ul>',25),n=[s];function d(h,c,p,_,b,S){return a(),t("div",null,n)}const T=e(i,[["render",d]]);export{m as __pageData,T as default};
