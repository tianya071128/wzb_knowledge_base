import{_ as e,c as t,o as a,aR as n,d0 as o}from"./chunks/framework.DLAwTCsc.js";const u=JSON.parse('{"title":"HTTP 传输大文件","description":"","frontmatter":{},"headers":[],"relativePath":"http/bigFile.md","filePath":"03_网络协议/01_http/08_传输大文件.md","lastUpdated":1739447932000}'),r={name:"http/bigFile.md"},c=n('<h1 id="http-传输大文件" tabindex="-1">HTTP 传输大文件 <a class="header-anchor" href="#http-传输大文件" aria-label="Permalink to &quot;HTTP 传输大文件&quot;">​</a></h1><p>现在网络的资源越来越大, HTTP 也就需要高效快速的传输这些大文件</p><p>HTTP/1.1 是一个文本协议, 需要通过一定的规则来判断报文的起始和结束. HTTP 通过单独的 TCP 通道传输数据, 那么判断报文结束也就是下一个报文的开始, 那么重点在于判断报文的结束. 请求(响应)行和头部字段是固定的结构比较好判断, 重要在于判断实体数据的结束.</p><p>在 HTTP/1.1 中, 是通过 <code>Content-Length: size(固定长度)</code> 或 <code>Transfer-Encoding: chunked</code> 来判断实体数据的结束</p><p><code>Content-Length: 628</code>: 标识了实体数据的长度, 就可以判断出实体数据的结束以及报文的结束</p><p><code>Transfer-Encoding: chunked</code>: 标识了实体数据是不确定长度的, 使用流式传输, HTTP 层会对数据进行封装, 最后会采用 CRLF(空行) 标识实体数据的结束以及报文的结束</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p><strong>“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。</strong></p></div><h2 id="数据压缩" tabindex="-1">数据压缩 <a class="header-anchor" href="#数据压缩" aria-label="Permalink to &quot;数据压缩&quot;">​</a></h2><p>采用 gzip、deflate、br 等压缩方式传输数据, 传输的数据就能够减少, 但是增加了压缩和解压的时间.</p><h2 id="分块传输" tabindex="-1">分块传输 <a class="header-anchor" href="#分块传输" aria-label="Permalink to &quot;分块传输&quot;">​</a></h2><p>HTTP 层将数据分块后给 TCP 进行传输, 客户端也就可以每次接收一部分数据进行处理(当然在浏览器会等待数据全部传输完成再交给应用), 将数据化整为零</p><p>HTTP 在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。</p><p>HTTP 层会对分块传输的数据进行再次编码， 编码规则如图：</p><p><img src="'+o+'" alt="img" loading="lazy"></p><p><a href="https://time.geekbang.org/column/article/104456" target="_blank" rel="noreferrer">本章节主要见极客文章</a></p>',15),d=[c];function p(i,s,_,h,l,T){return a(),t("div",null,d)}const P=e(r,[["render",p]]);export{u as __pageData,P as default};
