import{_ as a,c as i,o as e,aR as l,fC as t,fD as r,fE as o}from"./chunks/framework.DLAwTCsc.js";const b=JSON.parse('{"title":"内存术语","description":"","frontmatter":{},"headers":[],"relativePath":"devtools/memory/term.md","filePath":"04_更多/02_开发者工具/33_内存_内存术语.md","lastUpdated":1739447932000}'),p={name:"devtools/memory/term.md"},s=l('<h1 id="内存术语" tabindex="-1">内存术语 <a class="header-anchor" href="#内存术语" aria-label="Permalink to &quot;内存术语&quot;">​</a></h1><p>如下是内存分析中的常用术语</p><h2 id="对象大小" tabindex="-1">对象大小 <a class="header-anchor" href="#对象大小" aria-label="Permalink to &quot;对象大小&quot;">​</a></h2><p>可以将内存视为包含基元类型（如数字和字符串）和对象（关联数组）的图表。它可直观地表示为一个图表，其中包含多个互连的点，如下所示：</p><p><img src="'+t+'" alt="img" loading="lazy"></p><p>对象可以通过两种方式保留内存：</p><ul><li>直接通过对象本身。</li><li>通过保留对其他对象的引用来隐式处理这些对象，从而阻止这些对象被垃圾回收器（简称 GC）自动处置。</li></ul><p>其中, 浅层大小(Shallow Size) 和 保留的大小(Retained Size) 表示这两种方式的内存大小</p><p><img src="'+r+'" alt="img" loading="lazy"></p><h3 id="浅层大小-shallow-size" tabindex="-1">浅层大小(Shallow Size) <a class="header-anchor" href="#浅层大小-shallow-size" aria-label="Permalink to &quot;浅层大小(Shallow Size)&quot;">​</a></h3><p><strong>这是对象本身占用的内存大小。</strong></p><p>典型的 JavaScript 对象会预留一些内存用于自身的说明和存储立即值。通常情况下，<strong>只有数组和字符串才能有明显的浅层大小</strong>。不过，字符串和外部数组的主存储空间通常位于渲染器内存中，仅在 JavaScript 堆上公开一个小型封装容器对象。</p><p>渲染程序内存是渲染被检查页面的进程的内存：原生内存 + 页面的 JS 堆内存 + 页面启动的所有专用工作器的 JS 堆内存。不过，即使是小对象也可以阻止其他对象被自动垃圾回收进程处置，从而间接占用大量内存。</p><h3 id="保留的大小-retained-size" tabindex="-1">保留的大小(Retained Size) <a class="header-anchor" href="#保留的大小-retained-size" aria-label="Permalink to &quot;保留的大小(Retained Size)&quot;">​</a></h3><p><strong>这是对象本身及其无法从 GC 根访问的从属对象被删除后释放的内存大小。</strong></p><p>GC 根由句柄组成，这些句柄在从原生代码引用 V8 之外的 JavaScript 对象时创建（本地或全局）。所有此类句柄都可以在堆快照中找到，具体路径如下：GC 根 &gt; 处理范围和 GC 根 &gt; 全局句柄。在本文档中描述句柄，但没有深入介绍浏览器实现细节，可能会让人感到困惑。您无需担心 GC 根和句柄。</p><p>存在许多内部 GC 根，其中的大部分都不需要用户关注。从应用的角度来看，存在以下种类的根：</p><ul><li>Window 全局对象（在每个 iframe 中）。堆快照中有一个距离字段，它是距离窗口的最短保留路径的属性引用数量。</li><li>文档 DOM 树，由可通过遍历文档到达的所有原生 DOM 节点组成。并非所有文档都有 JS 封装容器，但如果它们有封装容器，那么当文档处于活动状态时，封装容器将会保持活跃状态。</li><li>有时，对象可能会由调试程序上下文和开发者工具控制台保留（例如，在控制台评估后）。在调试程序中清除控制台并移除活动断点，创建堆快照。 内存图从根开始，根可以是浏览器的 window 对象，也可以是 Node.js 模块的 Global 对象。您无法控制此根对象的垃圾回收方式。</li></ul><p><img src="'+o+'" alt="img" loading="lazy"></p><p><strong>任何无法从根访问的内容都会被 GC 回收。</strong></p><h2 id="对象保留树" tabindex="-1">对象保留树 <a class="header-anchor" href="#对象保留树" aria-label="Permalink to &quot;对象保留树&quot;">​</a></h2><p>堆是互连对象的网络。在数学领域，此结构称为图或内存图。图表由通过边连起来的节点构成，两者都被赋予了标签。</p><ul><li>节点（或对象）使用用于构建节点的构造函数名称进行标记。</li><li>边缘使用属性的名称进行标记。</li></ul><h2 id="支配项" tabindex="-1">支配项 <a class="header-anchor" href="#支配项" aria-label="Permalink to &quot;支配项&quot;">​</a></h2><p>支配项由树结构组成，因为每个对象只有一个支配项。对象的支配项可能缺少对其所支配对象的直接引用；也就是说，支配项的树不是图表的生成树。</p><h2 id="v8-详细信息" tabindex="-1">V8 详细信息 <a class="header-anchor" href="#v8-详细信息" aria-label="Permalink to &quot;V8 详细信息&quot;">​</a></h2><h3 id="javascript-对象表示法" tabindex="-1">JavaScript 对象表示法 <a class="header-anchor" href="#javascript-对象表示法" aria-label="Permalink to &quot;JavaScript 对象表示法&quot;">​</a></h3><p>有三种原语类型：</p><ul><li>数字（例如，3.14159..），可以存储为： <ul><li>31 位立即数整数值（称为小整数 [SMI]），或</li><li>堆对象（称为堆数字）。堆编号用于存储不适合 SMI 格式的值（例如双精度浮点数），或在需要对值进行装箱（例如为其设置属性）时使用堆编号。</li></ul></li><li>布尔值（true 或 false）</li><li>字符串（例如，“Werner Heisenberg”），可以存储为： <ul><li>虚拟机堆，或</li><li>渲染器内存的外部。系统会创建一个封装容器对象，用于访问外部存储空间，例如，该存储空间中存储了脚本源和从 Web 接收的其他内容，而不是复制到虚拟机堆上。</li></ul></li></ul><p>它们不能引用其他值，并且<strong>始终是叶或终止节点</strong>。</p><p>其他类型的：</p><ul><li><p>新 JavaScript 对象的内存从专用 JavaScript 堆（或虚拟机堆）分配。这些对象由 V8 的垃圾回收器管理，<strong>因此，只要存在至少一个对它们的强引用，它们就会保持活动状态。</strong></p></li><li><p>原生对象：是 JavaScript 堆之外的其他所有对象。与堆对象相反，原生对象在其生命周期内不由 V8 垃圾回收器管理，并且只能使用其 JavaScript 封装容器对象从 JavaScript 进行访问。</p></li><li><p>Cons 字符串：是一种由存储并联接的成对字符串组成的对象，是串联的结果。仅在需要时联接 cons 字符串内容。例如，需要构造已联接字符串的子字符串。</p><ul><li>例如，如果将 a 和 b 串联，则会得到表示串联结果的字符串 (a, b)。如果您稍后将 d 与该结果串联，则会得到另一个 cons 字符串 ((a, b), d)。</li></ul></li><li><p>数组：数组是具有数字键的对象。它们在 V8 虚拟机中广泛使用，用于存储大量数据。用作字典的成套键值对由数组支持。</p></li><li><p>映射：用于描述对象种类及其布局的对象。例如，映射用于描述实现<a href="https://chromium.googlesource.com/external/github.com/v8/v8.wiki/+/60dc23b22b18adc6a8902bd9693e386a3748040a/Design-Elements.md" target="_blank" rel="noreferrer">快速属性访问</a>的隐式对象层次结构。</p></li></ul><h3 id="对象组" tabindex="-1">对象组 <a class="header-anchor" href="#对象组" aria-label="Permalink to &quot;对象组&quot;">​</a></h3><p>每个原生对象组都由保持对彼此的相互引用的对象组成。例如，在 DOM 子树中，每个节点都有一个指向其父级的链接，并链接到下一个子级和下一个同级，从而形成一个连通图。请注意，原生对象不会在 JavaScript 堆中表示，因此它们的大小为零。而是会创建封装容器对象。</p><p>每个封装容器对象都会保留对相应原生对象的引用，用于将命令重定向到自身。相应对象组会自行持有封装容器对象。但是，这不会导致出现无法回收的循环，因为 GC 足够智能，可以释放封装容器不再被引用的对象组。但是，忘记释放单个封装容器将保留整个组和关联的封装容器。</p>',35),n=[s];function c(d,h,_,u,m,g){return e(),i("div",null,n)}const f=a(p,[["render",c]]);export{b as __pageData,f as default};
