import{_ as t,c as a,o as d,aR as e,c$ as o}from"./chunks/framework.DLAwTCsc.js";const u=JSON.parse('{"title":"HTTP 缓存","description":"","frontmatter":{},"headers":[],"relativePath":"http/cache.md","filePath":"03_网络协议/01_http/07_缓存.md","lastUpdated":1739447932000}'),r={name:"http/cache.md"},i=e('<h1 id="http-缓存" tabindex="-1">HTTP 缓存 <a class="header-anchor" href="#http-缓存" aria-label="Permalink to &quot;HTTP 缓存&quot;">​</a></h1><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术, 这样就节省了传输的时间, <strong>是性能优化的重要手段</strong></p><p>在 HTTP 传输链路中, 很多环节都存在缓存, 主要分为客户端缓存和服务端缓存. 对于前端而言主要接触的是客户端缓存</p><p><strong>HTTP 缓存主要分为两种: 强缓存和协商缓存</strong></p><p><img src="'+o+'" alt="Http缓存.jpg" loading="lazy"></p><h2 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h2><p>强缓存表示浏览器直接从缓存中提取资源, 而不需要发送 HTTP 请求, 在谷歌浏览器开发者工具中显示 HTTP 状态码为 200(disk Cache 或 memory Cache). disk Cache(硬盘缓存), memory Cache(内存缓存) 缓存位置由浏览器控制的.</p><p>是否强缓存主要有 Cache-Control、Expires、Pragma 三个字段决定, 优先级为 Pragma &gt; Cache-Control &gt; Expires</p><h3 id="pragma" tabindex="-1">Pragma <a class="header-anchor" href="#pragma" aria-label="Permalink to &quot;Pragma&quot;">​</a></h3><p>Pragma 是 HTTP/1.1 之前版本的历史遗留字段, 仅作为与 HTTP/1.0 的向后兼容而定义.</p><p>属于通用首部字段, 但目前一般只存在于客户端发送的请求中, 用于要求 HTTP 所有中间服务器不返回缓存的资源(<strong>兼容不支持 HTTP/1.1 协议的服务器</strong>)</p><p><strong>Pragma 只有一个取值, 就是 no-cache, 表示不使用强缓存, 需要进行协商缓存</strong></p><h3 id="expires-过期时间" tabindex="-1">Expires: 过期时间 <a class="header-anchor" href="#expires-过期时间" aria-label="Permalink to &quot;Expires: 过期时间&quot;">​</a></h3><p><strong>Expires 属于响应头部字段, 只存在于响应报文中, 是一个绝对时间值, 告知客户端资源的有效期, 当下次发送请求时, 客户端会比较当前时间(取决于客户端时间)和 Expires 时间判断缓存是否新鲜.</strong></p><p>当首部字段 Cache-Control 有<strong>指定 max-age 指令</strong>时，比起首部字段 Expires，会优先处理 max-age 指令。, e.g: <code>Expires: Wed, 04 Jul 2012 08:26:05 GMT</code></p><div class="tip custom-block"><p class="custom-block-title">提示</p><p>采用绝对时间的头部字段一般不可靠, 因为客户端时间可能跟服务端时间不一致</p></div><h3 id="cache-control-缓存行为" tabindex="-1">Cache-Control: 缓存行为 <a class="header-anchor" href="#cache-control-缓存行为" aria-label="Permalink to &quot;Cache-Control: 缓存行为&quot;">​</a></h3><p>Cache-Control 是一个通用首部字段, 也就是请求报文和响应报文都可以使用</p><p><strong>指令的参数是可选的, 多个指令之间通过 &quot;,&quot; 分隔, e.g: <code>Cache-Control: private, max-age=0, no-cache</code></strong></p><p>当在请求报文中出现时, 可选指令为(加粗为常用的):</p><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>no-cache</strong></td><td>无</td><td>强制向源服务器再次验证, 浏览器强制刷新请求报文中存在</td></tr><tr><td>no-store</td><td>无</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>max-age = [ 秒]</td><td>必需</td><td>响应的最大 Age 值</td></tr><tr><td>max-stale( = [ 秒])</td><td>可省略</td><td>接收已过期的响应</td></tr><tr><td>min-fresh = [ 秒]</td><td>必需</td><td>期望在指定时间内的响应仍有效</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>only-if-cached</td><td>无</td><td>从缓存获取资源</td></tr><tr><td>cache-extension</td><td>-</td><td>新指令标记（token）</td></tr></tbody></table><p>当在响应报文中出现时, 可选指令为(加粗为常用的);</p><table><thead><tr><th>指令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>无</td><td>可向任意方提供响应的缓存</td></tr><tr><td>private</td><td>可省略</td><td>仅向特定用户返回响应</td></tr><tr><td><strong>no-cache</strong></td><td>可省略</td><td>缓存前必须先确认其有效性</td></tr><tr><td><strong>no-store</strong></td><td>无</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>no-transform</td><td>无</td><td>代理不可更改媒体类型</td></tr><tr><td>must-revalidate</td><td>无</td><td>可缓存但必须再向源服务器进行确认</td></tr><tr><td>proxy-revalidate</td><td>无</td><td>要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td><strong>max-age = [ 秒]</strong></td><td>必需</td><td>响应的最大 Age 值</td></tr><tr><td>s-maxage = [ 秒]</td><td>必需</td><td>公共缓存服务器响应的最大 Age 值</td></tr><tr><td>cache-extension</td><td>-</td><td>新指令标记（token）</td></tr></tbody></table><div class="warning custom-block"><p class="custom-block-title">注意</p><p>由上表可知, Cache-Control 出现在请求和响应的行为是不一致的</p></div><ul><li><p>no-cache: 缓存前需要先验证</p><p>从客户端角度看(出现在请求报文中): 表示需要向源目标服务器验证缓存新鲜度(不会从客户端使用缓存资源, 以及中间代理服务器)</p><p>从服务端角度看: 表示可以缓存资源但是每次需要先向源目标服务器验证缓存新鲜度</p></li><li><p>no-store: 不进行缓存</p><p>客户端角度: 不使用缓存, 直接获取最新资源</p><p>服务端角度: 不要对此资源进行缓存</p></li><li><p>max-age: 资源有效期时间</p><p>客户端角度; 判断资源的缓存时间是否小于 max-age 指定时间, 如果小于的话, 那么使用缓存资源</p><p>服务端角度: 对资源进行指定时间的缓存, 在这个时间内, 缓存都是有效的</p></li></ul><h2 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h2><p>协商缓存的前提条件是<strong>第一次响应时, 响应报文预先提供了 “Last-modified” 或 “ETag”字段, 并且缓存过期或不进行强缓存, 此时会进行协商缓存</strong></p><p>HTTP 协议通过一系列 &quot;If&quot; 开头的请求头部字段, 专门用来提供给服务器进行验证资源是否过期, <strong>如果资源没有变, 服务器就回应一个“304 Not Modified”，表示缓存依然有效，浏览器就可以更新一下有效期，然后放心大胆地使用缓存了。</strong></p><p>条件请求(&quot;If&quot; 开头头部字段)一共有五个, 常用为两个:</p><ul><li>if-Modified-Since: 常用条件请求字段, 检测最后修改日期是否变化</li><li>If-None-Match: 常用条件请求字段, 检测 ETag 是否变化</li><li>If-Unmodified-Since</li><li>If-Match</li><li>If-Range</li></ul><h3 id="etag-if-none-match" tabindex="-1">ETag/If-None-Match <a class="header-anchor" href="#etag-if-none-match" aria-label="Permalink to &quot;ETag/If-None-Match&quot;">​</a></h3><p>ETag: 资源的唯一标识, 主要用于解决资源修改了时间但无法准确判断是否修改内容</p><p>ETag 还有强弱之分, 强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。</p><p><strong>如果在第一次获取资源时返回了 ETag 字段, 那么后续协商缓存过程中请求报文就会添加 <code>If-None-Match</code> 携带 ETag 让服务端校验文件是否新鲜, 如果文件新鲜的话, 就返回 <code>304 Not Modified</code> 响应</strong></p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>如果第一次响应时同时存在 ETag 和 Last-Modified 时, 那么在协商缓存阶段会同时发送 <code>If-None-Match</code> 和 <code>If-Modified-Since</code> 字段, 一般来说都是 ETag 校验优先, 但是具体策略依据服务端自行实现的.</p></div><h3 id="last-modified-if-modified-since" tabindex="-1">Last-Modified/If-Modified-Since <a class="header-anchor" href="#last-modified-if-modified-since" aria-label="Permalink to &quot;Last-Modified/If-Modified-Since&quot;">​</a></h3><p>Last-Modified: 资源的最后修改时间, 有可能资源修改时间变化了, 但是内容没有变化</p><p>如果资源存在 <code>Last-Modified</code>, 协商缓存阶段就会通过 <code>If-Modified-Since</code> 携带 <code>Last-Modified</code> 给服务端校验文件是否新鲜</p><h2 id="浏览器强制刷新行为" tabindex="-1">浏览器强制刷新行为 <a class="header-anchor" href="#浏览器强制刷新行为" aria-label="Permalink to &quot;浏览器强制刷新行为&quot;">​</a></h2><div class="warning custom-block"><p class="custom-block-title">注意</p><p><strong>在浏览器中, 强制刷新就是在请求报文中添加 <code>Cache-Control: no-cache</code>, 从而重新向服务器发送请求</strong></p><p>可以 ctrl + f5 强制刷新发现请求报文存在 <code>Cache-Control: no-cache</code> 和 <code>Pragma: no-cache</code> 字段</p><p><strong>通过在标签页中输入 URI 打开资源的话, 与强制刷新一样, 不会进行强缓存</strong></p><p>可以在标签页打开 URI, 发现这个 URI 的请求报文中存在 <code>Cache-Control: max-age=0</code> 字段</p><p><strong>并且不会携带 If 条件请求头部字段, 也就不会进行协商缓存</strong></p></div>',40),c=[i];function n(s,p,l,h,g,m){return d(),a("div",null,c)}const T=t(r,[["render",n]]);export{u as __pageData,T as default};
