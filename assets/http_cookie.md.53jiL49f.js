import{_ as o,c as e,o as i,aR as a}from"./chunks/framework.DLAwTCsc.js";const u=JSON.parse('{"title":"Cookie","description":"","frontmatter":{},"headers":[],"relativePath":"http/cookie.md","filePath":"03_网络协议/01_http/06_cookie.md","lastUpdated":1739447932000}'),t={name:"http/cookie.md"},c=a('<h1 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">​</a></h1><p>HTTP 是 &quot;无状态&quot; 的, 而为了让其变得 &quot;有状态&quot;, 就衍生了 cookie 机制.</p><p>cookie 是服务器颁发给客户端的凭证, 存储在客户端的, 是 &quot;浏览器绑定&quot; 的, 换台电脑或浏览器就不会共享这个 cookie</p><p>当每次发送 HTTP 请求时, 浏览器就会自动携带这个 cookie, 这样服务器就可以识别用户了</p><p><strong>Cookie 存储大小一般为 4 k</strong></p><h2 id="cookie-相关头字段" tabindex="-1">Cookie 相关头字段 <a class="header-anchor" href="#cookie-相关头字段" aria-label="Permalink to &quot;Cookie 相关头字段&quot;">​</a></h2><p>响应头字段 Set-Cookie 和请求头字段 Cookie。</p><h3 id="set-cookie-设置-cookie" tabindex="-1">Set-Cookie: 设置 cookie <a class="header-anchor" href="#set-cookie-设置-cookie" aria-label="Permalink to &quot;Set-Cookie: 设置 cookie&quot;">​</a></h3><p>服务器通过响应头字段 <code>Set-Cookie</code> 通知浏览器设置其 cookie, 可以通过设置多个 <code>Set-Cookie</code> 响应头字段来设置多个 cookie</p><p>服务器通过 <code>Set-Cookie: key=value;Max-Age=10;Domain=www.chrono.com;...</code> 格式设置 Cookie, 浏览器接收到后就会将其设置保存起来</p><h3 id="cookie-发送-cookie" tabindex="-1">Cookie: 发送 Cookie <a class="header-anchor" href="#cookie-发送-cookie" aria-label="Permalink to &quot;Cookie: 发送 Cookie&quot;">​</a></h3><p>客户端发送 HTTP 时, 会根据域名来筛选合适的 Cookie, 发送相对应的 Cookie 给服务器</p><h2 id="cookie-的属性" tabindex="-1">Cookie 的属性 <a class="header-anchor" href="#cookie-的属性" aria-label="Permalink to &quot;Cookie 的属性&quot;">​</a></h2><p>一般来说, Cookie 中的信息都比较重要, 就需要一些额外手段来具体设置 Cookie</p><h3 id="过期时间-expires-和-max-age" tabindex="-1">过期时间: Expires 和 Max-Age <a class="header-anchor" href="#过期时间-expires-和-max-age" aria-label="Permalink to &quot;过期时间: Expires 和 Max-Age&quot;">​</a></h3><p><code>Expires</code> 和 <code>Max-Age</code> 属性设置 cookie 的过期时间, 当超过设置的时间后浏览器就会判定 Cookie 失效, 从而删除 Cookie</p><ul><li><p>Expires: 绝对时间, 形式为符合 HTTP-date 规范的时间戳。. e.g; <code>Expires: Fri, 07-Jun-19 08:19:00 GMT;</code></p></li><li><p>Max-Age: 相对时间, 在 cookie 失效之前需要经过的秒数, 单位为秒. e.g: <code>Max-Age: 10</code></p></li></ul><p>当两者同时出现时, 优先采用 <code>Max-Age</code> 属性</p><div class="tip custom-block"><p class="custom-block-title">提示</p><p>很多头部字段设置过期时间的时候都会采用两个绝对和相对时间值, 但优先采用相对时间值.</p><p>因为客户端和服务端的时间可能不一样, 采用绝对时间时, 时间值不一定准确.</p></div><h3 id="作用域-domain-和-path" tabindex="-1">作用域: Domain 和 Path <a class="header-anchor" href="#作用域-domain-和-path" aria-label="Permalink to &quot;作用域: Domain 和 Path&quot;">​</a></h3><p><code>Domain</code> 和 <code>Path</code> 属性设置 Cookie 的作用域, 让浏览器仅发送特定的服务器和 URI, 避免被其他网站盗用</p><p>浏览器在发送 Cookie 时, 就会从 URI 中提取出 host 和 path 部分, 对比 Domain 和 Path 属性, 符合条件才会发送 Cookie</p><ul><li><p>Domain: 设置 Cookie 的访问域名, 默认为当前域名. 可以设置父域名(一级域名), 那么子域名也就可以访问(二级域名)</p><blockquote><p>例如设置 <code>Domain: .test.com</code> , 那么下面的子域名 <code>a.test.com</code>, <code>b.test.com</code> 都可以访问</p><p>通常使用这一特性可以实现单点登录效果</p></blockquote></li><li><p>Path: 设置 Cookie 的主机下访问路径, 默认为 /</p></li></ul><h3 id="安全性-httponly-和-secure-和-samesite" tabindex="-1">安全性: HttpOnly 和 Secure 和 SameSite <a class="header-anchor" href="#安全性-httponly-和-secure-和-samesite" aria-label="Permalink to &quot;安全性: HttpOnly 和 Secure 和 SameSite&quot;">​</a></h3><p>Cookie 一般带有用户信息的凭证, 需要保证 Cookie 一定的安全性</p><ul><li><p>HttpOnly: 设置此 Cookie 不能通过 <code>document.cookie</code> 访问 Cookie</p></li><li><p>Secure: 设置此 Cookie 只能通过 HTTPS 协议传输, 但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。</p></li><li><p>SameSite: 设置此 Cookie 是否在跨站时发送</p><ul><li><code>None </code>浏览器会在同站请求、跨站请求下继续发送 cookies，不区分大小写。</li><li><code>Strict</code> 浏览器将只在访问相同站点时发送 cookie。（在原有 Cookies 的限制条件上的加强，如上文 “Cookie 的作用域” 所述）</li><li><code>Lax</code> 与 <code>Strict</code> 类似，但用户从外部站点导航至 URL 时（例如通过链接）除外。 在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到 URL 时才会发送。</li></ul><div class="warning custom-block"><p class="custom-block-title">注意</p><p>Cookie 是跟域名绑定在一起的, 如果发送 HTTP 请求的域名不符合 Cookie 的条件, 那么此 Cookie 就不会发送.</p><p>当在浏览器标签页打开一个页面时, 页面发送的 HTTP 请求如果产生了跨站(注意不是跨域)的话, 是否发送这个 HTTP 请求的 Cookie, 就需要根据这个 Cookie 的 SameSite 属性来判断</p><p>例如在 a.test.com 中通过表单发送给 b.test2.com 数据, 那么是否发送 属于 b.test2.com 的 Cookie?</p><p>首先需要筛选出符合 b.test2.com 作用域的 Cookie, 其次判断这个请求是否跨站了(在这个例子是跨站的), 根据 SameSite 属性判断跨站是否能够发送 Cookie.</p><p><strong>记住, Cookie 是跟域名绑定的, 需要判断这个 Cookie 是否发送, 需要根据 HTTP 请求的域名以及当前页面 URI 综合判断</strong></p></div><p>参考文档: <a href="https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html" target="_blank" rel="noreferrer">SameSite 属性</a>、<a href="https://zhuanlan.zhihu.com/p/121048298" target="_blank" rel="noreferrer">SameSite 小识</a></p><h2 id="跨域-cookie" tabindex="-1">跨域 Cookie <a class="header-anchor" href="#跨域-cookie" aria-label="Permalink to &quot;跨域 Cookie&quot;">​</a></h2><p>见<a href="/wzb_knowledge_base/http/cors.html#跨域-cookie">HTTP-跨域 cookie</a></p></li></ul>',26),k=[c];function p(r,l,s,d,n,h){return i(),e("div",null,k)}const C=o(t,[["render",p]]);export{u as __pageData,C as default};
