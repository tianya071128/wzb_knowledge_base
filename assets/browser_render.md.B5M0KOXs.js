import{_ as e,c as a,o as t,aR as o,bW as r,bX as l,bY as i,bZ as s,b_ as n,b$ as d,c0 as c,c1 as p,c2 as g,c3 as m,c4 as h,c5 as u}from"./chunks/framework.DLAwTCsc.js";const C=JSON.parse('{"title":"渲染流程","description":"","frontmatter":{},"headers":[],"relativePath":"browser/render.md","filePath":"01_前端/04_浏览器/03_渲染流程.md","lastUpdated":1739447932000}'),_={name:"browser/render.md"},b=o('<h1 id="渲染流程" tabindex="-1">渲染流程 <a class="header-anchor" href="#渲染流程" aria-label="Permalink to &quot;渲染流程&quot;">​</a></h1><p>渲染流程过于复杂，所以渲染模块将执行过程分为很多子阶段，输入的 HTML 数据经过这些子阶段，最后输出像素。这一过程叫做<strong>渲染流水线</strong>，其大致流程如下图：</p><p><img src="'+r+'" alt="img" loading="lazy"></p><p>按照渲染的顺序，可分为如下几个阶段：<strong>构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成</strong>。每个阶段重点关注以下三个内容：</p><ul><li>开始每个子阶段都有其<strong>输入内容</strong>；</li><li>然后每个子阶段有其<strong>处理过程</strong>；</li><li>最终每个子阶段会生成<strong>输出内容</strong>。</li></ul><h2 id="构建-dom-树" tabindex="-1">构建 DOM 树 <a class="header-anchor" href="#构建-dom-树" aria-label="Permalink to &quot;构建 DOM 树&quot;">​</a></h2><p>浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为可理解的结构 —— DOM 树。</p><ul><li><p>输入内容：非常简单的 HTML 文件</p></li><li><p>处理过程：由 HTML 解析器解析，<strong>注意的是这个会解析出所有的 HTML 结构，包含了可见和不可见的元素的</strong></p></li><li><p>输出内容：树状结构的 DOM，是保存在<strong>内存中树状数据结构</strong>，在 js 中可通过 <code>document</code> 访问</p></li></ul><p><img src="'+l+'" alt="img" loading="lazy"></p><h2 id="样式计算-recalculate-style" tabindex="-1">样式计算（Recalculate Style） <a class="header-anchor" href="#样式计算-recalculate-style" aria-label="Permalink to &quot;样式计算（Recalculate Style）&quot;">​</a></h2><p>样式计算是为了计算出 DOM 节点中每个元素的具体样式：</p><ul><li><p>输入内容：CSS 的来源主要有以下三个：</p><ul><li>通过 link 引用的外部 CSS 文件</li><li>通过 link 引用的外部 CSS 文件</li><li>元素的 style 属性内嵌的 CSS</li></ul></li><li><p>处理过程：大体分为以下三步完成：</p><ul><li><p>将 CSS 转换为浏览器可以理解的结构 —— <code>styleSheets</code>，在 js 中可通过 <code>document.styleSheets</code> 访问</p></li><li><p>转换样式表中的属性值，使其标准化。需要将所有值(如 2em、blue、bold)转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p><p><img src="'+i+'" alt="img" loading="lazy"></p></li><li><p>根据 CSS 的继承规则和层叠规则计算 DOM 树中每个节点的样式属性</p></li></ul></li><li><p>输出内容：每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</p></li></ul><p><img src="'+s+'" alt="image-20220517105907083" loading="lazy"></p><h2 id="布局阶段-构建布局树-layouttree" tabindex="-1">布局阶段 -构建布局树(LayoutTree) <a class="header-anchor" href="#布局阶段-构建布局树-layouttree" aria-label="Permalink to &quot;布局阶段 -构建布局树(LayoutTree)&quot;">​</a></h2><p>接下来需要<strong>计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</strong></p><ul><li>输入内容：DOM 树 和 DOM 样式结构树(ComputedStyle)</li><li>处理过程：主要有两个任务，<strong>创建布局树和布局计算</strong>。 <ul><li>创建布局树：DOM 中含有很多不可见的元素(head 标签、display:none 属性的元素等)，所以<strong>需要构建一棵只包含可见元素布局树(DOM 树中所有不可见的节点都没有包含到布局树中)</strong>。在构建布局树过程中浏览器大致完成了如下工作： <ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；</li><li>不可见的节点会被布局树忽略掉，如 head 标签、display:none 属性的元素等</li></ul></li><li>布局计算：根据布局树，计算布局树节点的坐标位置了，<strong>把布局运算的结果重新写回布局树中</strong>。</li></ul></li><li>输出内容：布局树 -- <strong>节点坐标位置以及边界框大小等信息</strong></li></ul><p><img src="'+n+'" alt="img" loading="lazy"></p><h2 id="分层-构建图层树-layertree" tabindex="-1">分层 - 构建图层树(LayerTree) <a class="header-anchor" href="#分层-构建图层树-layertree" aria-label="Permalink to &quot;分层 - 构建图层树(LayerTree)&quot;">​</a></h2><p>页面中有些复杂的效果(如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等)，为了实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>。</p><ul><li>输入内容：布局阶段生成的布局树。</li><li>处理过程：浏览器页面会被分成很多图层，这些图层叠加后合成了最终的页面。通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。<strong>但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</strong></li><li>输出内容：图层树(LayerTree)</li></ul><p><img src="'+d+'" alt="img" loading="lazy"></p><div class="tip custom-block"><p class="custom-block-title">什么条件会创建图层</p><p>在 <a href="https://time.geekbang.org/column/article/118826" target="_blank" rel="noreferrer">极客时间-渲染流程</a> 这篇文章中的条件存在错误(也可能是浏览器更新的问题)，目前而言，浏览器会更智能的创建图层。</p><ul><li>拥有层叠上下文的条件，并且满足一定条件(这个条件暂不得知，应该是位置会发生变化时) <ul><li>例如固定定位(<code>position: fixed;</code>)时，触发一定条件</li><li>例如发生动画时</li><li>。。。</li></ul></li><li>节点可滚动时(<code>overflow</code>)，即存在滚动条，并且还需要满足一定条件(测试存在背景颜色时)，会生成单独图层</li><li>指定 <code>will-change</code> 属性告知浏览器这个节点需要生成单独图层</li></ul><p><a href="/wzb_knowledge_base/html/layers.html" target="blank">这个链接有一些会生成图层的例子</a>，打开 <code>devtools</code> 的 <code>layers(图层)</code> 选项卡可查看</p></div><h2 id="绘制-paint-图层绘制列表" tabindex="-1">绘制(Paint) - 图层绘制列表 <a class="header-anchor" href="#绘制-paint-图层绘制列表" aria-label="Permalink to &quot;绘制(Paint) - 图层绘制列表&quot;">​</a></h2><p>完成图层树的构建之后，渲染引擎会<strong>对图层树中的每个图层进行绘制</strong>：</p><ul><li>输入内容：图层树(LayerTree)</li><li>处理过程：渲染引擎实现图层的绘制，会把每一个图层绘制拆分成很多小的<strong>绘制指令</strong>，在把这些指令按照顺序组成一个<strong>待绘制列表</strong>。绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。<strong>绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。</strong></li><li>输出内容：就是这些每个<strong>待绘制列表</strong> —— <strong>绘制列表只是用来记录绘制顺序和绘制指令的列表</strong></li></ul><p><img src="'+c+'" alt="img" loading="lazy"></p><div class="tip custom-block"><p class="custom-block-title">查看图层的绘制列表</p><p>可以打开“开发者工具”的“Layers”标签，选择图层，双击图层即可出现一个 <code>Profiler(分析器)</code> 标签，下图的区域 1 就是图层的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p><p><img src="'+p+'" alt="img" loading="lazy"></p></div><h2 id="光栅化-raster-实际图层绘制" tabindex="-1">光栅化(raster) - 实际图层绘制 <a class="header-anchor" href="#光栅化-raster-实际图层绘制" aria-label="Permalink to &quot;光栅化(raster) - 实际图层绘制&quot;">​</a></h2><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而<strong>实际上绘制操作是由渲染引擎中的合成线程</strong>来完成的，当图层的绘制列表准备好后，主线程会把该绘制列表提交（commit）给合成线程：</p><p><img src="'+g+'" alt="img" loading="lazy"></p><h3 id="分块-将图层划分为图块-tile" tabindex="-1">分块 - 将图层划分为图块(tile) <a class="header-anchor" href="#分块-将图层划分为图块-tile" aria-label="Permalink to &quot;分块 - 将图层划分为图块(tile)&quot;">​</a></h3><p>通常一个页面很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。通过视口，用户只能看到页面的一部分，就没有必要一次性绘制出所有图层内容。</p><p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p><p><img src="'+m+'" alt="img" loading="lazy"></p><p><strong>然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化线程来执行的</strong>。</p><h3 id="光栅化-将图块转换为位图" tabindex="-1">光栅化 - 将图块转换为位图 <a class="header-anchor" href="#光栅化-将图块转换为位图" aria-label="Permalink to &quot;光栅化 - 将图块转换为位图&quot;">​</a></h3><p>光栅化就是<strong>将图块转换为位图</strong>。合成线程将图层划分为图块后，<strong>会将图块发送到光栅化线程进行光栅化</strong>。渲染进程维护了一个<strong>光栅化线程池</strong>，所有的图块光栅化都是在线程池内执行的。通常，光栅化过程都会<strong>使用 GPU 来加速生成</strong>，使用 GPU 生成位图的过程叫快速光栅化，或者 GPU 光栅化。</p><p>光栅化操作绘制出图块后(多个光栅化线程并行处理的)，并将它们存储在 GPU 内存中。</p><p><img src="'+h+'" alt="image-20220518154946605" loading="lazy"></p><h2 id="合成-收集图块信息创建-compositor-frame" tabindex="-1">合成 - 收集图块信息创建 Compositor frame <a class="header-anchor" href="#合成-收集图块信息创建-compositor-frame" aria-label="Permalink to &quot;合成 - 收集图块信息创建 Compositor frame&quot;">​</a></h2><p>光栅化线程会将称为 <code>Draw quads</code> 的图块信息返回给合成线程，合成线程收集这些 <code>Draw quads</code> 图块信息创建出 <code>Compositor frame</code>，然后通过 <code>IPC</code> 将其传递给浏览器进程</p><table><thead><tr><th>名词</th><th>描述</th></tr></thead><tbody><tr><td>Draw quads</td><td>考虑到页面合成，包含诸如图块在内存中的位置以及在页面中绘制图块的位置等信息。</td></tr><tr><td>Compositor frame</td><td>代表页面框架的绘制四边形集合。</td></tr></tbody></table><h2 id="显示" tabindex="-1">显示 <a class="header-anchor" href="#显示" aria-label="Permalink to &quot;显示&quot;">​</a></h2><p>合成线程生成的 <code>Compositor frame</code> 提交给浏览器进程，其他渲染进程都可能把自己生成的 <code>compositor frame</code>发给 GPU 进程。</p><p>GPU 进程的 viz 线程里跑着一个 display 合成器，负责合成从不同进程发过来的 <code>compositor frame</code>。最后是 GPU 进程中的 viz 线程调用 OpenGL 的 API 把 compositor frame 绘制到屏幕上的。</p><p><img src="'+u+'" alt="composit" loading="lazy"></p><h2 id="渲染流水线总结" tabindex="-1">渲染流水线总结 <a class="header-anchor" href="#渲染流水线总结" aria-label="Permalink to &quot;渲染流水线总结&quot;">​</a></h2><p>整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示：</p><ol><li>构建 DOM 树：渲染进程将 HTML 内容转换为能够读懂的 <strong>DOM 树</strong>结构。</li><li>样式计算：渲染引擎将 CSS 样式表转化为浏览器可以理解的 <strong>styleSheets</strong>，计算出 DOM 节点的样式。</li><li><strong>布局</strong>：创建<strong>布局树</strong>，并计算元素的布局信息 -- 布局阶段任务艰巨，即使是最简单的页面布局，比如从上到下的块流，也必须考虑字体有多大以及在哪里换行，因为这些会影响段落的大小和形状；然后影响下一段需要的位置。</li><li>分层：对布局树进行分层，并生成<strong>图层树</strong>。</li><li>绘制：为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li><li>光栅化：合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li><li>合成：合成线程收集这些 <code>Draw quads</code> 图块信息创建出 <code>Compositor frame</code>，并通过 <code>IPC</code> 传递给浏览器进程。</li><li>显示：浏览器进程将 <code>Draw quads</code> 发送给 <code>GUP</code>，由 <code>GPU</code> 显示在屏幕上</li></ol><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://developer.chrome.com/blog/inside-browser-part3/" target="_blank" rel="noreferrer">Chrome - 深入了解现代网络浏览器</a></li><li><a href="https://www.youtube.com/watch?v=m-J-tbAlFic" target="_blank" rel="noreferrer">youtube - 浏览器</a></li><li><a href="https://time.geekbang.org/column/article/118205" target="_blank" rel="noreferrer">极客-渲染流程上</a></li><li><a href="https://time.geekbang.org/column/article/118826" target="_blank" rel="noreferrer">极客-渲染流程下</a></li></ul>',51),f=[b];function y(P,k,q,D,M,S){return t(),a("div",null,f)}const O=e(_,[["render",y]]);export{C as __pageData,O as default};
