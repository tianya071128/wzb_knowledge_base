import{_ as l,c as i,o as t,aR as a,cU as e,cV as o,cW as T}from"./chunks/framework.DLAwTCsc.js";const _=JSON.parse('{"title":"HTTP","description":"","frontmatter":{},"headers":[],"relativePath":"http/home.md","filePath":"03_网络协议/01_http/01_index.md","lastUpdated":1739447932000}'),r={name:"http/home.md"},h=a('<h1 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h1><p>HTTP: 超文本传输协议(HyperText Transfer Protocol), <strong>是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p><ul><li>超文本: 一开始互联网数据只是文本, 后面慢慢演变图片、视频、超链接, 也就是 &quot;超越了普通文本的文本&quot;</li><li>传输: 用于在 HTTP 请求和响应端传输数据, 需要借助 TCP/IP 将数据传输数据</li><li>协议: 一种行为约定和规范, HTTP 参与者都应该遵守的协议, HTTP 不参与具体实现, 只是给出实现的规范</li></ul><h2 id="http-的历史" tabindex="-1">HTTP 的历史 <a class="header-anchor" href="#http-的历史" aria-label="Permalink to &quot;HTTP 的历史&quot;">​</a></h2><p>HTTP 可参考: <a href="https://time.geekbang.org/column/article/97837" target="_blank" rel="noreferrer">极客时间-HTTP 专栏</a></p><h3 id="http-0-9" tabindex="-1">HTTP/0.9 <a class="header-anchor" href="#http-0-9" aria-label="Permalink to &quot;HTTP/0.9&quot;">​</a></h3><p>20 世纪 90 年代, 网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</p><ul><li>只有 &quot;GET&quot; 方法</li><li>采用纯文本格式</li><li>响应结束后立即关闭连接</li></ul><h3 id="http-1-0" tabindex="-1">HTTP/1.0 <a class="header-anchor" href="#http-1-0" aria-label="Permalink to &quot;HTTP/1.0&quot;">​</a></h3><p>在 1996 年正式发布, <strong>HTTP/1.0 并不是一个“标准”，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个“备忘录”。</strong></p><ul><li>增加了 HEAD、POST 等新方法；</li><li>增加了响应状态码，标记可能的错误原因；</li><li>引入了协议版本号概念；</li><li>引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；</li><li>传输的数据不再仅限于文本。</li></ul><h3 id="http-1-1" tabindex="-1">HTTP/1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP/1.1&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">重要</p><p>它是一个“正式的标准”，而不是一份可有可无的“参考文档”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。</p></div><p>在&quot;浏览器大战&quot;结束后的 1999 年发布, 使用最广泛, 也是目前主要在使用的协议, 但 h2 市场占有率也在逐步增大</p><ul><li>增加了 PUT、DELETE 等新的方法；</li><li>增加了缓存管理和控制；</li><li>明确了连接管理，允许持久连接；</li><li>允许响应数据分块（chunked），利于传输大文件；</li><li>强制要求 Host 头，让互联网主机托管成为可能。</li></ul><h3 id="http-2-0" tabindex="-1">HTTP/2.0 <a class="header-anchor" href="#http-2-0" aria-label="Permalink to &quot;HTTP/2.0&quot;">​</a></h3><p>在 2015 年发布, 考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，</p><ul><li>二进制协议，不再是纯文本；</li><li>可发起多个请求，废弃了 1.1 里的管道；</li><li>使用专用算法压缩头部，减少数据传输量；</li><li>允许服务器主动向客户端推送数据；</li><li>增强了安全性，“事实上”要求加密通信。</li></ul><h3 id="http-3-0" tabindex="-1">HTTP/3.0 <a class="header-anchor" href="#http-3-0" aria-label="Permalink to &quot;HTTP/3.0&quot;">​</a></h3><p>未来</p><h2 id="http-特点" tabindex="-1">HTTP 特点 <a class="header-anchor" href="#http-特点" aria-label="Permalink to &quot;HTTP 特点&quot;">​</a></h2><ul><li>HTTP 最大的优点是简单、灵活和易于扩展；</li><li>HTTP 是无状态的, 当然可以借助头部字段实现 &quot;状态&quot;;</li><li>HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；</li><li>HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；</li><li>HTTP 是明文传输的;</li><li>HTTP 无法验证通信双方身份信息;</li><li>HTTP 性能不算差, 也不算好;</li></ul><h2 id="http-报文" tabindex="-1">HTTP 报文 <a class="header-anchor" href="#http-报文" aria-label="Permalink to &quot;HTTP 报文&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">注意</p><p>HTTP/1.1 是一个纯文本协议, 报文都是 ASCII 码的文本</p><p>而与之对应的, HTTP/2.0 TCP 等大多数都是二进制协议, 二进制协议一般可以用比特来表示信息, 需要特定程序进行解析信息</p></div><p>报文格式如下图所示:</p><p><img src="'+e+'" alt="img" loading="lazy"></p><h3 id="起始行" tabindex="-1">起始行 <a class="header-anchor" href="#起始行" aria-label="Permalink to &quot;起始行&quot;">​</a></h3><ul><li><p>请求行: 请求报文的起始行</p><ol><li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li><li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li><li>版本号：表示报文使用的 HTTP 协议版本。</li></ol><p>用空格(space)分隔, 最后用 CRLF 换行表示结束, 特定的格式才能解析数据</p><p><img src="'+o+'" alt="img" loading="lazy"></p></li><li><p>状态行:响应报文的起始行</p><ol><li>版本号：表示报文使用的 HTTP 协议版本；</li><li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li><li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li></ol><p><img src="'+T+'" alt="img" loading="lazy"></p></li></ul><h3 id="头部字段" tabindex="-1">头部字段 <a class="header-anchor" href="#头部字段" aria-label="Permalink to &quot;头部字段&quot;">​</a></h3><p>请求报文和响应报文的头部字段格式都是一样的, 格式是 <code>key-value</code> 格式, 使用 <code>:</code> 分隔, 最后用 <code>CRLF</code> 表示字段结束. e.g: <code>Host: 127.0.0.1</code></p><div class="tip custom-block"><p class="custom-block-title">头部字段注意点:</p><ol><li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li><li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li><li>key 后面必须紧接着“:”，不能有空格，而“:”后的 value 前可以有多个空格；</li><li>字段的顺序是没有意义的，可以任意排列不影响语义；</li><li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</li></ol></div><p>HTTP 一般通过头部字段来实现各种功能, 并且可以通过自定义头部字段实现协议的扩展. 头部字段大致可以分为以下四类:</p><ol><li>通用字段：在请求头和响应头里都可以出现；</li><li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li><li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li><li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li></ol>',33),p=[h];function s(c,d,n,P,u,H){return t(),i("div",null,p)}const b=l(r,[["render",s]]);export{_ as __pageData,b as default};
