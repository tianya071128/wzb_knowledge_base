import{_ as s,c as a,o as n,aR as e,cw as i,cx as l,cy as p,cz as o,cA as d,cB as c}from"./chunks/framework.DLAwTCsc.js";const v=JSON.parse('{"title":"包安装机制","description":"","frontmatter":{},"headers":[],"relativePath":"npm/install.md","filePath":"02_工程化/06_npm/07_包安装机制.md","lastUpdated":1739447932000}'),t={name:"npm/install.md"},r=e(`<h1 id="包安装机制" tabindex="-1">包安装机制 <a class="header-anchor" href="#包安装机制" aria-label="Permalink to &quot;包安装机制&quot;">​</a></h1><p>包安装机制随着版本的迭代，安装机制也不断进化，以如下为例，假设项目<code>App</code>中有如下三个依赖：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>A</code>、<code>B</code>、<code>C</code>三个模块又有如下依赖：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>A@1.0.0 -&gt; D@1.0.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>B@1.0.0 -&gt; D@2.0.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>C@1.0.0 -&gt; D@2.0.0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="嵌套安装-npm-2-x-时代" tabindex="-1">嵌套安装 - npm 2.x 时代 <a class="header-anchor" href="#嵌套安装-npm-2-x-时代" aria-label="Permalink to &quot;嵌套安装 - npm 2.x 时代&quot;">​</a></h2><p>在 <code>npm 2.x</code> 时代，安装方式简单直接：以递归的方式，按照包依赖的树形结构下载到项目的 <code>node_modules</code> 目录中。</p><p>执行<code>npm install</code>后，项目<code>App</code>的<code>node_modules</code>会变成如下目录结构：</p><div class="language-tex vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tex</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">├── node_modules</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── A@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   │   └── node_modules</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   │   │   └── D@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── B@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   │   └── node_modules</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   │   │   └── D@2.0.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   └── C@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   │   └── node_modules</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   │   │   └── D@2.0.0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>嵌套安装的缺点：</p><ul><li><p><strong>会造成相同模块的大量冗余问题</strong></p></li><li><p><strong>会造成目录结构嵌套比较深的问题</strong></p></li></ul><h2 id="扁平安装-npm-3-x-时代" tabindex="-1">扁平安装 - npm 3.x 时代 <a class="header-anchor" href="#扁平安装-npm-3-x-时代" aria-label="Permalink to &quot;扁平安装 - npm 3.x 时代&quot;">​</a></h2><p>从 <code>npm 3.x</code> 时代开始采用扁平化的方式来安装模块：<strong>优先将模块安装在一级<code>node_modules</code>中</strong>。当安装到相同模块时，判断这个模块是否已安装(符合已安装模块的版本)，如果符合则跳过，不符合则在当前模块的<code>node_modules</code>下安装该模块。</p><p>此时，<code>APP</code> 安装后 <code>node_modules</code>会变成如下目录结构：</p><div class="language-tex vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tex</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">├── node_modules</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── A@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── B@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   │   └── node_modules</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   │   │   └── D@2.0.0 # 重复模块 - 版本不兼容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   ├── C@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   │   └── node_modules</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   │   │   └── D@2.0.0 # 重复模块 - 与一级版本不兼容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">│   └── D@1.0.0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="广度优先安装" tabindex="-1">广度优先安装 <a class="header-anchor" href="#广度优先安装" aria-label="Permalink to &quot;广度优先安装&quot;">​</a></h3><p>当安装版本遇到相同模块但版本不兼容的时候，哪个会被优先安装在一级<code>node_modules</code>目录下呢？</p><p><strong>安装包的时候，首先将<code>package.json</code>里的依赖按照首字母（@排最前）进行排序，然后将排序后的依赖包按照广度优先遍历的算法进行安装，最先被安装到的模块将会被优先安装在一级<code>node_modules</code>目录下</strong>。</p><blockquote><p>广度优先：优先将同一层的依赖安装好，而不是优先将一个模块及其所有的子模块安装好。</p></blockquote><p>如下是对结果的验证，可以看到 <code>semver</code> 安装在 <code>node_modules</code> 顶层的模块版本是不一样的：</p><p><img src="`+i+'" alt="image-20220705104550485" loading="lazy"></p><p><img src="'+l+'" alt="image-20220705104653414" loading="lazy"></p><h3 id="已安装包情况-安装新包" tabindex="-1">已安装包情况，安装新包 <a class="header-anchor" href="#已安装包情况-安装新包" aria-label="Permalink to &quot;已安装包情况，安装新包&quot;">​</a></h3><p><strong>在一级<code>node_moudles</code>中已经存在依赖包的情况下，新安装的依赖包如果存在版本冲突，则会安装到新依赖包的<code>node_modules</code>中</strong>。</p><p><img src="'+p+'" alt="image-20220705110613544" loading="lazy"></p><h3 id="减少包树中的重复" tabindex="-1">减少包树中的重复 <a class="header-anchor" href="#减少包树中的重复" aria-label="Permalink to &quot;减少包树中的重复&quot;">​</a></h3><p>假设我们卸载了 <code>node_modules</code> 中某个顶层包的话，此时 <code>node_modules</code> 就会变成如图所示：</p><p><img src="'+o+'" alt="image-20220705111250699" loading="lazy"></p><p>可以通过 <code>npm dedupe</code> 命令来减少包树中的重复，将依赖关系进一步向上移动来简化整体结构，从而可以更有效地由多个依赖包共享：</p><p><img src="'+d+'" alt="image-20220705112022699" loading="lazy"></p><h2 id="package-lock-json-npm-v5-时代" tabindex="-1">package-lock.json - npm v5 时代 <a class="header-anchor" href="#package-lock-json-npm-v5-时代" aria-label="Permalink to &quot;package-lock.json - npm v5 时代&quot;">​</a></h2><p>在安装包的时候，通常在 <code>package.json</code> 文件中都是只锁定大版本：<code>vue: ^2.5.17</code>，此时安装包时可能会下载 <code>2.6.14</code>，下载大版本下的最新版本。</p><p><strong>但是这种机制最大的问题在于</strong>：当包的小版本存在更新时，不同开发者的版本可能不一致。</p><p><code>npm v5</code> 引入了 <code>package-lock.json</code> 文件，精确描述了<code>node_modules</code> 目录下所有的包的树状依赖结构，每个包的版本号都是完全精确的，<strong>用于锁定项目依赖的版本</strong>。</p><ul><li>当项目初始化安装模块时，会生成 <code>pckage-lock.json</code> 文件，用于描述项目的依赖关系以及版本</li><li>当协同开发者安装模块时，根据 <code>package-lock.json</code> 文件安装项目依赖，这样不同开发者的版本都一致</li></ul><p>对于应用开发时，建议把<code>package-lock.json</code>文件提交到代码版本仓库，从而让你的团队成员、运维部署人员或<code>CI</code>系统可以在执行<code>npm install</code>时安装的依赖版本都是一致的。</p><p>对于包(公共库)开发时，则不应把<code>package-lock.json</code>文件发布到仓库中。实际上，<code>npm</code>也默认不会把<code>package-lock.json</code>文件发布出去。之所以这么做，是因为库项目一般是被其他项目依赖的，在不写死的情况下，就可以复用主项目已经加载过的包，而一旦库依赖的是精确的版本号那么可能会造成包的冗余。</p><h2 id="安装流程" tabindex="-1">安装流程 <a class="header-anchor" href="#安装流程" aria-label="Permalink to &quot;安装流程&quot;">​</a></h2><p><code>npm install</code> 安装包的整体流程如图：</p><p><img src="'+c+'" alt="05" loading="lazy"></p><ul><li><p>检查 <code>.npmrc</code> 文件：优先级为：项目级的 <code>.npmrc</code> 文件 &gt; 用户级的 <code>.npmrc</code> 文件&gt; 全局级的 <code>.npmrc</code> 文件 &gt; npm 内置的 <code>.npmrc</code> 文件</p></li><li><p>检查项目中有无 <code>lock</code> 文件。</p><ul><li><p>无 <code>lock</code> 文件：</p><ul><li><p>从 <code>npm</code> 远程仓库获取包信息</p></li><li><p>根据 <code>package.json</code>构建依赖树，构建过程：</p><ul><li><p>构建依赖树时，不管其是直接依赖还是子依赖的依赖，优先将其放置在 <code>node_modules</code> 根目录。</p></li><li><p>当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 <code>node_modules</code> 下放置该模块。</p></li><li><p>注意这一步只是确定逻辑上的依赖树，并非真正的安装，后面会根据这个依赖结构去下载或拿到缓存中的依赖包</p></li></ul></li><li><p>在缓存中依次查找依赖树中的每个包</p><ul><li><p>不存在缓存：</p><ul><li><p>从 <code>npm</code> 远程仓库下载包</p></li><li><p>校验包的完整性</p><ul><li><p>校验不通过：</p><ul><li><p>重新下载</p></li><li><p>校验通过：</p><ul><li>将下载的包复制到 <code>npm</code> 缓存目录</li><li>将下载的包按照依赖结构解压到 <code>node_modules</code></li></ul></li></ul></li></ul></li></ul></li><li><p>存在缓存：将缓存按照依赖结构解压到 <code>node_modules</code></p></li></ul></li><li><p>生成 <code>lock</code> 文件</p></li></ul></li></ul></li><li><p>有 <code>lock</code> 文件：</p><ul><li>检查 <code>package.json</code> 中的依赖版本是否和 <code>package-lock.json</code> 中的依赖有冲突。</li><li>如果没有冲突，直接跳过获取包信息、构建依赖树过程，开始在缓存中查找包信息，后续过程相同</li></ul></li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://juejin.cn/post/6844903870578032647#heading-0%60" target="_blank" rel="noreferrer">掘金-前端工程化（5）</a></p>',43),h=[r];function k(u,m,g,E,b,_){return n(),a("div",null,h)}const q=s(t,[["render",k]]);export{v as __pageData,q as default};
