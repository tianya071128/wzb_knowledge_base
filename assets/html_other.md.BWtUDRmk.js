import{_ as e,c as o,o as r,aR as t}from"./chunks/framework.DLAwTCsc.js";const m=JSON.parse('{"title":"其他主题","description":"","frontmatter":{},"headers":[],"relativePath":"html/other.md","filePath":"01_前端/01_html/10_other.md","lastUpdated":1739447932000}'),a={name:"html/other.md"},i=t('<h1 id="其他主题" tabindex="-1">其他主题 <a class="header-anchor" href="#其他主题" aria-label="Permalink to &quot;其他主题&quot;">​</a></h1><h2 id="cors-设置属性-crossorigin" tabindex="-1">CORS 设置属性：crossorigin <a class="header-anchor" href="#cors-设置属性-crossorigin" aria-label="Permalink to &quot;CORS 设置属性：crossorigin&quot;">​</a></h2><p>在 HTML5 中，一些 HTML 元素提供了对 CORS 的支持。例如：<code>audio</code>、<code>img</code>、<code>link</code>、<code>script</code>和 <code>video</code> 均有一个跨域属性(crossorigin)，用于配置元素获取数据的 CORS 请求</p><p>这个属性是枚举的，并具有以下可能的值：</p><table><thead><tr><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td><code>anonymous</code></td><td>对此元素的 CORS 请求将不设置凭据标志。</td></tr><tr><td><code>use-credentials</code></td><td>对此元素的 CORS 请求将设置凭证标志；这意味着请求将提供凭据。</td></tr><tr><td><code>&quot;&quot;</code></td><td>设置一个空的值，如 <code>crossorigin</code> 或 <code>crossorigin=&quot;&quot;</code>，和设置 <code>anonymous</code> 的效果一样。</td></tr></tbody></table><p>这些 HTML 元素默认是可以实现跨域资源请求的，并不会像 xhr 请求资源一样，需要服务端设置 CORS 跨域。</p><p><strong>但如果添加了 crossorigin 属性，就会通过 CORS 方式加载这些资源，此时就需要服务器进行 CORS 跨域设置</strong></p><p><strong>注意：通过 js 脚本设置 crossorigin 时，需要使用 crossOrigin 属性</strong></p><h3 id="对于-img-图片" tabindex="-1">对于 img 图片 <a class="header-anchor" href="#对于-img-图片" aria-label="Permalink to &quot;对于 img 图片&quot;">​</a></h3><p>使用 <code>crossorigin</code> 可以实现下载跨域图片</p><p>见另外章节：<a href="/wzb_knowledge_base/html/img.html#跨域图片-cookie">img 图片</a></p><h3 id="对于-script-脚本" tabindex="-1">对于 script 脚本 <a class="header-anchor" href="#对于-script-脚本" aria-label="Permalink to &quot;对于 script 脚本&quot;">​</a></h3><p>设置 <code>crossorigin</code> 属性可以更好获取到脚本的具体错误信息了，具体参考 <a href="https://blog.csdn.net/qq_40028324/article/details/107076751" target="_blank" rel="noreferrer">crossorigin 属性</a></p><div class="tip custom-block"><p class="custom-block-title">提示</p><ul><li>不设置 crossorigin：正常请求脚本，服务器无需设置 CORS 也可以请求。但是在 onerror 全局事件中捕获的信息不全。</li><li>设置 crossorigin（anonymous）：使用 CORS 形式请求脚本，服务器需设置。捕获的错误信息比较全。</li><li>设置 crossorigin（use-credentials）：使用 CORS 形式请求脚本，并且会携带凭证，服务器也需要允许携带凭证</li></ul></div><h2 id="preload-prefetch-预加载内容" tabindex="-1">Preload/Prefetch：预加载内容 <a class="header-anchor" href="#preload-prefetch-预加载内容" aria-label="Permalink to &quot;Preload/Prefetch：预加载内容&quot;">​</a></h2><p><code>&lt;link rel=“prefetch”&gt;</code>是一个指令，告诉浏览器<strong>获取</strong>下一次导航<strong>可能需要的资源</strong>。这主要意味着资源将以极低的优先级获取（因为浏览器<em>知道</em>当前页面中需要的所有内容都比我们<em>猜测</em>下一个页面中可能需要的资源更重要）。这意味着预取的主要用例是加速下一个导航而不是当前导航。</p><p><code>&lt;link rel=&quot;preload&quot;&gt;</code> 用来指定页面加载后很快会被用到的资源，所以在页面加载的过程中，我们希望在浏览器开始主体渲染之前尽早 preload。</p><p>具体参考：</p><ul><li><a href="https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/" target="_blank" rel="noreferrer">文章-预加载：它有什么用？</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Link_prefetching_FAQ" target="_blank" rel="noreferrer">MDN-链接预取常见问题</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types/preload" target="_blank" rel="noreferrer">链接类型：preload</a></li></ul><p>在 vue-cli 脚本架生成的 vue 项目中，这两个是内置的，但在不支持或支持度较差的浏览器中，可能会有副作用。具体见<a href="https://cli.vuejs.org/zh/guide/html-and-static-assets.html#preload" target="_blank" rel="noreferrer">vue-cli</a></p>',20),s=[i];function c(d,l,n,h,p,g){return r(),o("div",null,s)}const u=e(a,[["render",c]]);export{m as __pageData,u as default};
