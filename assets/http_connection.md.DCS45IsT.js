import{_ as a,c as t,o as e,aR as o,cX as i,cY as l,cZ as p,c_ as s}from"./chunks/framework.DLAwTCsc.js";const g=JSON.parse('{"title":"连接管理","description":"","frontmatter":{},"headers":[],"relativePath":"http/connection.md","filePath":"03_网络协议/01_http/05_连接管理.md","lastUpdated":1739447932000}'),n={name:"http/connection.md"},r=o('<h1 id="连接管理" tabindex="-1">连接管理 <a class="header-anchor" href="#连接管理" aria-label="Permalink to &quot;连接管理&quot;">​</a></h1><p>HTTP 底层借助 TCP/IP 进行数据传输, 在 HTTP/1.1 之前默认为短连接, HTTP/1.1 默认为长连接</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>短连接和长连接的说法是 HTTP 层面上的, 并不是 TCP/IP 的特性, TCP 连接一般不会主动关闭的</p></div><h2 id="短连接" tabindex="-1">短连接 <a class="header-anchor" href="#短连接" aria-label="Permalink to &quot;短连接&quot;">​</a></h2><p>在 HTTP/0.9、HTTP/1.0 时代, 每次 HTTP 请求前需要先与服务器建立连接, 收到响应报文后会立即关闭连接</p><p>短连接每次 HTTP 请求都要经历三次握手(1.5 RTT)建立连接, 四次挥手(2 RTT)断开连接</p><p><img src="'+i+'" alt="img" loading="lazy"></p><h2 id="长连接" tabindex="-1">长连接 <a class="header-anchor" href="#长连接" aria-label="Permalink to &quot;长连接&quot;">​</a></h2><p>在 HTTP/1.1 协议之后, HTTP 请求默认为长连接(也称为持久连接), 也就是在一个 HTTP 请求之后, 不会关闭 TCP 连接, 继续复用 TCP 连接通信</p><p><strong>浏览器默认为每个域名启用 6~8 个 TCP 连接, 启用 TCP 连接是需要内存的, 不能无限制</strong></p><p><strong>TCP 协议还有 &quot;慢启动&quot;, &quot;拥塞窗口&quot;等特性, 所以打开了一段时间的&quot;热连接&quot;更快</strong></p><p><strong>长连接还有一个重要问题就是如何区分多个报文的开始和结束, 所以最好使用 &quot;Content-Length&quot; 头明确响应实体的长度, 标记报文结束. 如果是流式传输, body 长度不能立即确定, 就爱使用分块传输编码</strong></p><p><img src="'+l+'" alt="img" loading="lazy"></p><h2 id="头部字段配置" tabindex="-1">头部字段配置 <a class="header-anchor" href="#头部字段配置" aria-label="Permalink to &quot;头部字段配置&quot;">​</a></h2><p>HTTP/1.1 默认为长连接, 也可以通过 <code>Connection: keep-alive</code> 开启长连接, 通过 <code>Connection: close</code> 关闭长连接, 当客户端或服务端设置了 <code>Connection: close</code> 后, 另一方就会在 HTTP 请求结束后关闭连接.</p><p>长连接也有一些小缺点, TCP 连接长时间不关闭, 就需要内存存储 TCP 的状态(套接字). 所以也要有合适的时机关闭 TCP 连接</p><div class="tip custom-block"><p class="custom-block-title">提示</p><p>在 ng 服务器上, 可以设置:</p><ol><li>使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</li><li>使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</li></ol></div><h2 id="队头阻塞" tabindex="-1">队头阻塞 <a class="header-anchor" href="#队头阻塞" aria-label="Permalink to &quot;队头阻塞&quot;">​</a></h2><p>HTTP 规定报文是&quot;一发一收&quot;, 只有在上一个请求结束后才能进行下一请求, 如果上一个请求没有结束的话, 后续请求就要一直等待了, 就会造成队头阻塞</p><p>请求遵循着先进先出的队列, 从队列讲(因为在解析 HTML 时会优先请求一些资源, 但如果入了 HTTP 请求队列的话), 是没有优先级区分的.</p><p><img src="'+p+'" alt="img" loading="lazy"></p><div class="tip custom-block"><p class="custom-block-title">注意</p><p>HTTP/1.1 的队头阻塞是针对 HTTP 协议层面的</p><p>而在 HTTP/2.0 的队头阻塞是针对 TCP 协议层面的</p></div><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><ol><li>浏览器会为每个域名开启 6~8 个 TCP 连接</li><li>域名分片: 浏览器会以域名限制 TCP 连接, 那么可以对同一服务器多增加几个域名 在 HTTP/2.0 中, 域名分片甚至会影响性能. 目前最近不好使用这一过时的技术, 升级到 HTTP/2.0 即可.</li></ol><h2 id="管道化连接-pipeline" tabindex="-1">管道化连接(pipeline) <a class="header-anchor" href="#管道化连接-pipeline" aria-label="Permalink to &quot;管道化连接(pipeline)&quot;">​</a></h2><p>在 HTTP/1.1 中定义了管道化连接的概念, 即可以并发多个请求, 具体如下图所示:</p><p><img src="'+s+'" alt="img" loading="lazy"></p><p>但是主要有两个限制:</p><ol><li><p>客户端必须一个请求完整交付到 tcp 缓冲区之后才能交付下一个；服务端响应也是一样。</p><p>HTTP 是一个文本协议, 需要根据数据特定的格式来判断报文的开始和结束, 这样就需要一个请求完整交付到 TCP 传输(TCP 乱序发顺序接), 才能保证数据的完整</p></li><li><p>响应的时候必须按请求的顺序发送响应</p><p>HTTP 请求之间是没有标示的, 在响应的时候要按照请求的顺序响应, 不能客户端不能判断响应的报文属于哪个请求的响应</p></li></ol><p>由于这些限制, 大多数浏览器都抛弃了管道化的尝试, 在 ios 中有所尝试</p><p><a href="https://www.zhihu.com/question/340651010" target="_blank" rel="noreferrer">参考-知乎问题</a></p>',31),c=[r];function T(d,P,h,_,u,m){return e(),t("div",null,c)}const H=a(n,[["render",T]]);export{g as __pageData,H as default};
