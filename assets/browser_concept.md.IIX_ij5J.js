import{_ as a,c as t,o,aR as e,c6 as r,c7 as s,c8 as l,c9 as i,ca as c,cb as n,cc as p}from"./chunks/framework.DLAwTCsc.js";const O=JSON.parse('{"title":"渲染流程 - 概念","description":"","frontmatter":{},"headers":[],"relativePath":"browser/concept.md","filePath":"01_前端/04_浏览器/04_渲染相关概念.md","lastUpdated":1739447932000}'),d={name:"browser/concept.md"},h=e('<h1 id="渲染流程-概念" tabindex="-1">渲染流程 - 概念 <a class="header-anchor" href="#渲染流程-概念" aria-label="Permalink to &quot;渲染流程 - 概念&quot;">​</a></h1><p>以下是一些跟渲染流水线相关的概念或问题</p><h2 id="重排-更新了元素的几何属性" tabindex="-1">重排 - 更新了元素的几何属性 <a class="header-anchor" href="#重排-更新了元素的几何属性" aria-label="Permalink to &quot;重排 - 更新了元素的几何属性&quot;">​</a></h2><p>通过 <code>JavaScript</code> 或者 <code>CSS</code> 修改元素的<strong>几何位置属性</strong>，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫<strong>重排</strong>。</p><p><strong>重排需要更新完整的渲染流水线，所以开销也是最大的。</strong></p><p><img src="'+r+'" alt="img" loading="lazy"></p><div class="tip custom-block"><p class="custom-block-title">通过性能面板观察重排</p><p>打开这个<a href="/wzb_knowledge_base/html/重排和重绘.html" target="blank">html</a>，点击按钮触发重排，通过性能面板可以看到重排的过程，如下图：</p><p><img src="'+s+'" alt="image-20220520095359664" loading="lazy"></p><p><strong>注意：如果直接操作 DOM 的话，例如：<code>dom.style.height = &#39;300px&#39;</code> 的话，是不会重新构建 DOM 树的，但是通过 <code>dom.innerHTML = ...</code> 的话，就会重新构建 DOM 树(解析 HTML)</strong></p></div><h2 id="重绘-更新元素的绘制属性" tabindex="-1">重绘 - 更新元素的绘制属性 <a class="header-anchor" href="#重绘-更新元素的绘制属性" aria-label="Permalink to &quot;重绘 - 更新元素的绘制属性&quot;">​</a></h2><p>通过 <code>JavaScript</code> 或者 <code>CSS</code> 修改元素的<strong>绘制属性</strong>，例如改变元素的背景颜色等。那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫<strong>重绘</strong>。</p><p>相较于重排操作，<strong>重绘省去了布局阶段，布局阶段是非常复杂的，所以执行效率会比重排操作要高一些</strong>。</p><p><strong>注意：在极客时间课程中，重绘同时省去了分层阶段(更新图层树)，但是在性能面板中，还是会触发分层阶段的。</strong></p><p><img src="'+l+'" alt="image-20220520105313051" loading="lazy"></p><div class="tip custom-block"><p class="custom-block-title">通过性能面板观察重绘</p><p>打开这个<a href="/wzb_knowledge_base/html/重排和重绘.html" target="blank">html</a>，点击按钮触发重排，通过性能面板可以看到重绘的过程，如下图：</p><p><img src="'+i+'" alt="image-20220520102454904" loading="lazy"></p></div><h2 id="分层和合成" tabindex="-1">分层和合成 <a class="header-anchor" href="#分层和合成" aria-label="Permalink to &quot;分层和合成&quot;">​</a></h2><h3 id="帧-vs-帧率" tabindex="-1">帧 VS 帧率 <a class="header-anchor" href="#帧-vs-帧率" aria-label="Permalink to &quot;帧 VS 帧率&quot;">​</a></h3><p>帧：渲染流水线生成的每一副图片称为一帧</p><p>帧率：渲染流水线每秒更新了多少帧称为帧率(FPS)</p><p>一般设备屏幕刷新率是 60 次 / 秒，所以要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。也就是说，<strong>渲染流水线的帧率不要慢于屏幕的刷新率</strong></p><p>如果渲染流水线每帧的生成时间太久，就会造成动画卡顿问题。Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。<strong>分层和合成机制代表了当今最先进的渲染技术</strong></p><h3 id="渲染流水线如何生成一帧图像" tabindex="-1">渲染流水线如何生成一帧图像？ <a class="header-anchor" href="#渲染流水线如何生成一帧图像" aria-label="Permalink to &quot;渲染流水线如何生成一帧图像？&quot;">​</a></h3><p>渲染流水线生成一帧图像的方式有如下三种：<strong>重排、重绘和合成</strong>。</p><p>这三种方式触发的渲染路径是不一同的，<strong>通常渲染路径越长，生成图像花费的时间就越多</strong>：</p><ul><li><p>重排：整个渲染流水线的每个阶段都执行一遍(构建 DOM 树可能不执行)</p></li><li><p>重绘：不需要布局阶段，比重排效率要高一些</p></li><li><p>合成：不需要触发布局、分层(构建图层树)、绘制几个阶段，如果采用了 GPU，那么合成的效率会非常高。</p></li></ul><h3 id="合成技术-——-分层、分块和合成。" tabindex="-1">合成技术 —— 分层、分块和合成。 <a class="header-anchor" href="#合成技术-——-分层、分块和合成。" aria-label="Permalink to &quot;合成技术 —— 分层、分块和合成。&quot;">​</a></h3><p>Chrome 中的合成技术，主要由三块组成 —— <strong>分层、分块和合成</strong>。</p><p>可以把一张网页想象由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。</p><p>将素材分解为多个图层的操作就称为<strong>分层</strong>，最后将这些图层合并到一起的操作就称为<strong>合成</strong>。</p><p>这样的话，当其中某个图层需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变操作时，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。</p><h4 id="分层" tabindex="-1">分层 <a class="header-anchor" href="#分层" aria-label="Permalink to &quot;分层&quot;">​</a></h4><p>在渲染流程中，<strong><a href="/wzb_knowledge_base/browser/render.html#分层-构建图层树-layertree">分层体现在生成布局树之后</a></strong>，渲染引擎会根据布局树的特点将其转换为图层树（Layer Tree），<strong>图层树中的每个节点都对应着一个图层</strong>，图层树是渲染流水线后续流程的基础结构。</p><div class="warning custom-block"><p class="custom-block-title">图层过多的问题</p><p>每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存</p></div><h4 id="合成" tabindex="-1">合成 <a class="header-anchor" href="#合成" aria-label="Permalink to &quot;合成&quot;">​</a></h4><p>在渲染流程中，通过<a href="/wzb_knowledge_base/browser/render.html#绘制-paint-图层绘制列表">绘制阶段</a>会根据图层树的每一个图层生成绘制列表，在<a href="/wzb_knowledge_base/browser/render.html#光栅化-raster-实际图层绘制">光栅化阶段</a>根据这些绘制列表生成图片，<strong>合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区</strong>。</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p><strong>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的</strong>。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p></div><h4 id="分块" tabindex="-1">分块 <a class="header-anchor" href="#分块" aria-label="Permalink to &quot;分块&quot;">​</a></h4><p>如果说分层是从宏观上提升了渲染效率，那么分块则是<strong>从微观层面提升了渲染效率</strong>。</p><p>通常页面比屏幕大的多，初次渲染时没有必要等到所有的图层都光栅化后显示在屏幕上。因此，合成线程会将<strong>每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块</strong>，这样就可以大大加速页面的显示速度。</p><p>不过因为设计到<strong>纹理上传</strong> —— 从计算机内存上传到 GPU 内存的操作会比较慢，所以 Chrome 还采用了一个策略 —— <strong>在首次合成图块的时候使用一个低分辨率的图片</strong>。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。</p><h3 id="合成-触发合成条件" tabindex="-1">合成 - 触发合成条件 <a class="header-anchor" href="#合成-触发合成条件" aria-label="Permalink to &quot;合成 - 触发合成条件&quot;">​</a></h3><p><strong>触发合成的方式是整个图层的几何变换，透明度变换，阴影等，这些变换都不会影响到图层的内容</strong>。</p><p>如果文字信息的改变，布局的改变，颜色的改变等内容变化就要牵涉到重排或者重绘了。</p><p>比如滚动页面的时候，整个页面内容没有变化，这时候做的其实是对图层做上下移动，这种操作直接在合成线程里面就可以完成了。</p><h3 id="合成-优化页面" tabindex="-1">合成 - 优化页面 <a class="header-anchor" href="#合成-优化页面" aria-label="Permalink to &quot;合成 - 优化页面&quot;">​</a></h3><p>当需要对某个元素做几何形状变换、透明度变换或者一些缩放操作时，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。</p><p>此时可以使用 <code>will-change</code> 属性来主动告诉渲染引擎将这个元素单独设置为图层，当对这个元素进行变换时，<strong>渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率</strong>。</p><p><strong>注意：<code>will-change</code> 属性只有在指定特定属性(例如：<code>opacity</code>、<code>transform</code>)时才会单独设置为图层，因为这些属性的变化才不会触发重排或重绘，可以直接在合成线程上渲染，从而启用 GPU 加速</strong></p><div class="tip custom-block"><p class="custom-block-title">通过性能面板观察重绘</p><p>打开这个<a href="/wzb_knowledge_base/html/合成.html" target="blank">html</a>，点击按钮触发动画，通过性能面板可以看到重绘的过程，如下图：</p><p><img src="'+c+'" alt="image-20220520152907612" loading="lazy"></p><p>可以看到，合成会跳过布局、绘制、光栅化(因为不需要重新生成图层位图)操作，此时效率是很高的</p></div><h2 id="dom-树" tabindex="-1">DOM 树 <a class="header-anchor" href="#dom-树" aria-label="Permalink to &quot;DOM 树&quot;">​</a></h2><h3 id="dom-是什么" tabindex="-1">DOM 是什么？ <a class="header-anchor" href="#dom-是什么" aria-label="Permalink to &quot;DOM 是什么？&quot;">​</a></h3><p>渲染引擎无法理解 HTML 文件字节流，所以要将其转化为渲染引擎能够理解的内部结构。在渲染引擎中，DOM 有三个层面的作用：</p><ul><li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li><li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li><li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li></ul><p>简言之，DOM 是<strong>表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容</strong>。</p><h3 id="dom-树如何生成" tabindex="-1">DOM 树如何生成? <a class="header-anchor" href="#dom-树如何生成" aria-label="Permalink to &quot;DOM 树如何生成?&quot;">​</a></h3><p>在渲染引擎内部，DOM 树由 <strong>HTML 解析器(HTMLParser)</strong> 的模块生成，它的职责就是负责将 HTML 字节流转换为 DOM 结构。</p><p><strong>网络进程加载了多少数据，HTML 解析器便解析多少数据：<strong>网络进程接收到响应头后，就会根据 <code>content-type</code> 判断文件的类型，如果是 HTML 类型的文件(<code>Content-Type: text/html</code> )，浏览器就会为该请求选择或者创建一个渲染进程。之后</strong>网络进程和渲染进程就会建立一个数据通道</strong>，网络进程下载了多少数据就通过这个通道传递给渲染进程，同时渲染进程通过 HTML 解析器将其解析为 DOM。</p><p>网络传输的是字节流的形式，转换为 DOM 需要经过三个阶段，<a href="https://time.geekbang.org/column/article/140140" target="_blank" rel="noreferrer">具体参考</a>：</p><p><img src="'+n+'" alt="img" loading="lazy"></p><h3 id="javascript-阻塞-dom-生成" tabindex="-1">JavaScript 阻塞 DOM 生成 <a class="header-anchor" href="#javascript-阻塞-dom-生成" aria-label="Permalink to &quot;JavaScript 阻塞 DOM 生成&quot;">​</a></h3><ul><li><p>内嵌脚本：当 <code>HTML</code> 解析器解析到 <code>&lt;script&gt;</code> 脚本标签时，就会暂停 <code>HTML</code> 的解析，因为<strong>接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构</strong>。</p></li><li><p>外链脚本：<strong>最新浏览器版本下，会先渲染已经解析好的 DOM 树</strong>。等到脚本下载执行的时候通过触发 重绘或重排 来重新渲染</p></li></ul><div class="warning custom-block"><p class="custom-block-title">预解析操作</p><p><strong>预解析操作</strong>：当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，<strong>预解析线程会提前下载这些文件</strong>。</p></div><h3 id="为什么最好将脚本文件放在最下面" tabindex="-1">为什么最好将脚本文件放在最下面？ <a class="header-anchor" href="#为什么最好将脚本文件放在最下面" aria-label="Permalink to &quot;为什么最好将脚本文件放在最下面？&quot;">​</a></h3><ol><li>放在 <code>&lt;body&gt;</code> 之后的话，此时 DOM 树已经解析完毕，<code>javascript</code> 直接操作 DOM 是没有问题的</li><li>放在 <code>&lt;body&gt;</code> 之后的话，<strong><code>JavaScript</code> 脚本不会阻塞页面的渲染</strong>：因为只要 DOM 树解析完成，渲染流水线就会继续执行后续流程，就会绘制一帧显示到屏幕上</li></ol><div class="warning custom-block"><p class="custom-block-title">注意注意注意注意</p><p>最新版本浏览器渲染流程似乎又有差异，<strong>当遇到脚本时，还是会阻塞 DOM 树的生成，但是会继续渲染页面。只是只渲染已经解析好的 DOM 树</strong></p></div><div class="tip custom-block"><p class="custom-block-title">提示</p><p>所以有时需要改善用户体验时，可以在 html 文件中加入一个骨架屏之类的，让页面显示一些内容出来，而不至于长时间白屏</p></div><h2 id="cssom-document-stylesheets" tabindex="-1">CSSOM - document.styleSheets <a class="header-anchor" href="#cssom-document-stylesheets" aria-label="Permalink to &quot;CSSOM - document.styleSheets&quot;">​</a></h2><ol><li><p>DOM 树 和 <code>CSSOM</code> 是串行解析的，先解析 DOM 树，后解析样式表。都是在渲染进程的主线程上进行解析</p></li><li><p>内嵌样式表(<code>&lt;style&gt;</code>标签)：会在 <code>解析 HTML</code> 后进行解析</p></li><li><p>外链样式表(<code>&lt;link&gt;</code> 引入)：会阻塞页面渲染。需要等到样式表下载完成后，进行样式计算，所以会阻塞初次页面渲染 -- <strong>注意这一点，当引入样式表太大导致加载时间过长的话，页面白屏时间会过长</strong></p><p><img src="'+p+'" alt="image-20220523173125734" loading="lazy"></p></li><li><p>动态样式表(通过脚本动态创建样式表引入)：不会阻塞页面初次渲染。在样式表下载完成后触发重排或重绘进行页面更新</p></li></ol><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://time.geekbang.org/column/article/140140" target="_blank" rel="noreferrer">极客 - DOM 树</a></li></ul>',68),g=[h];function m(b,u,_,k,M,f){return o(),t("div",null,g)}const S=a(d,[["render",m]]);export{O as __pageData,S as default};
