import{_ as t,c as i,o as e,aR as l}from"./chunks/framework.DLAwTCsc.js";const u=JSON.parse('{"title":"ESLint","description":"","frontmatter":{},"headers":[],"relativePath":"eslint/home.md","filePath":"02_工程化/02_eslint/01_eslint.md","lastUpdated":1739447932000}'),a={name:"eslint/home.md"},n=l('<h1 id="eslint" tabindex="-1">ESLint <a class="header-anchor" href="#eslint" aria-label="Permalink to &quot;ESLint&quot;">​</a></h1><h2 id="为什么需要-eslint" tabindex="-1">为什么需要 ESLint？ <a class="header-anchor" href="#为什么需要-eslint" aria-label="Permalink to &quot;为什么需要 ESLint？&quot;">​</a></h2><p>JS 是一门动态的弱类型语言，因为没有编译程序，为了寻找 JS 代码的错误需要在执行过程中不断调试。ESLint 就是用来在编码的过程中就发现问题而不是在执行中。</p><p>ESLint 是基于插件的，所有规则都被设计成可插入的。ESLint 也内置了一些规则，但这些规则与其他的插件并没有什么区别，规则本身和测试可以依赖于同样的模式。</p><p><strong>ESLint 是基于 Node.js 编写的，所以需要 Node 环境才能运行。例如 eslint-loader、vscode 中的 eslint 插件</strong></p><h2 id="eslint-的设计理念" tabindex="-1">ESLint 的设计理念 <a class="header-anchor" href="#eslint-的设计理念" aria-label="Permalink to &quot;ESLint 的设计理念&quot;">​</a></h2><p><strong>这与 Prettier 的设计理念是相反的，ESLint 一切皆可配置，Prettier 尽可能少的配置</strong></p><p>所有都是可拔插的</p><ul><li>内置规则和自定义规则共用一套规则 API</li><li>内置的格式化方法和自定义的格式化方法共用一套格式化 API</li><li>额外的规则和格式化方法能够在运行时指定</li><li>规则和对应的格式化方法并不强制捆绑使用</li></ul><p>每条规则:</p><ul><li>各自独立</li><li>可以开启或关闭（没有什么可以被认为“太重要所以不能关闭”）</li><li>可以将结果设置成警告或者错误</li></ul><p>另外:</p><ul><li>ESLint 并不推荐任何编码风格，规则是自由的</li><li>所有内置规则都是泛化的</li></ul><p>项目:</p><ul><li>通过丰富文档减少沟通成本</li><li>尽可能的简单透明</li><li>相信测试的重要性</li></ul>',15),s=[n];function o(r,_,d,p,c,h){return e(),i("div",null,s)}const E=t(a,[["render",o]]);export{u as __pageData,E as default};
