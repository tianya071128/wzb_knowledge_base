import{_ as s,c as i,o as a,aR as n,bm as l,bn as p,bo as e,bp as t,bq as h,br as k}from"./chunks/framework.DLAwTCsc.js";const D=JSON.parse('{"title":"事件循环-evnet loop","description":"","frontmatter":{},"headers":[],"relativePath":"js/eventloop.md","filePath":"01_前端/03_js/05_JS执行机制-事件循环.md","lastUpdated":1739447932000}'),r={name:"js/eventloop.md"},d=n('<h1 id="事件循环-evnet-loop" tabindex="-1">事件循环-evnet loop <a class="header-anchor" href="#事件循环-evnet-loop" aria-label="Permalink to &quot;事件循环-evnet loop&quot;">​</a></h1><p>JS 是运行在渲染进程的主线程的，并且这个主线程还需要处理 DOM，计算样式，处理布局，以及各种事件和网络请求事件等等，是非常繁忙的。</p><p>要处理这么多任务还需要保证页面渲染性能，就需要一个系统来统筹调度这些任务，这个系统就是事件循环系统。</p><h2 id="消息队列" tabindex="-1">消息队列 <a class="header-anchor" href="#消息队列" aria-label="Permalink to &quot;消息队列&quot;">​</a></h2><p><img src="'+l+'" alt="img" loading="lazy"></p><p>渲染进程会不断的从消息队列中取出任务，执行任务，反复如此。</p><p>消息队列<strong>是一种数据结构，存放要执行的任务</strong>。</p><p>渲染进程有一个 IO 线程专门用来接收其他进程传的消息，接收到消息后，会将这些消息封装成任务<strong>发送给主线程</strong>，主线程将其推入到消息队列中（消息队列也是主线程上的一个数据队列）。</p><h3 id="消息队列的任务类型" tabindex="-1">消息队列的任务类型 <a class="header-anchor" href="#消息队列的任务类型" aria-label="Permalink to &quot;消息队列的任务类型&quot;">​</a></h3><p>这里面包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p><p>消息队列中的任务种类繁多，就主要存在以下两个问题：</p><h3 id="问题一-如何处理高优先级的任务" tabindex="-1">问题一：如何处理高优先级的任务 <a class="header-anchor" href="#问题一-如何处理高优先级的任务" aria-label="Permalink to &quot;问题一：如何处理高优先级的任务&quot;">​</a></h3><p>针对这种情况，微任务就是用来解决高优先级的问题。</p><p>消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列（<strong>执行宏任务中的 JS 脚本时，会创建一个调用栈，以及这个微任务队列等等，详见。。。</strong>），在执行宏任务的过程中，可以将高优先级的任务推入到微任务队列，宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务</p><h3 id="问题二-单个任务执行时间过长" tabindex="-1">问题二：单个任务执行时间过长 <a class="header-anchor" href="#问题二-单个任务执行时间过长" aria-label="Permalink to &quot;问题二：单个任务执行时间过长&quot;">​</a></h3><p>因为所有的任务都是在单线程上执行的，一次只能执行一个任务，当一个任务执行时间过长的话，就会阻塞其他的任务</p><p><img src="'+p+`" alt="img" loading="lazy"></p><h2 id="宏任务" tabindex="-1">宏任务 <a class="header-anchor" href="#宏任务" aria-label="Permalink to &quot;宏任务&quot;">​</a></h2><p>消息队列中的任务也就是宏任务，主线程上类似于采用一个 for 循环，不断地从消息队列中取出任务并执行任务。</p><p>大致流程如下：</p><ul><li>先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；</li><li>然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；</li><li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；</li><li>最后统计执行完成的时长等信息。</li></ul><p><strong>宏任务的时间粒度比较大，用户设置的两个宏任务之间可能会被插入多个系统级的宏任务。</strong></p><div class="warning custom-block"><p class="custom-block-title">关于宏任务执行</p><p>当执行宏任务的 js 脚本时，并不是说会连续执行下去，有可能会将线程控制交给其他引擎。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 访问 DOM 时，(猜测)线程控制权就交给了 DOM 机制了，就可能会穿插其他的任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(testDom.scrollTop);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">buttonDom.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  testDom.scrollTop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> testDom.scrollTop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上述代码的任务执行过程如图：</p><p><img src="`+e+`" alt="image-20211122170556962" loading="lazy"></p></div><h2 id="微任务" tabindex="-1">微任务 <a class="header-anchor" href="#微任务" aria-label="Permalink to &quot;微任务&quot;">​</a></h2><p>当执行一段 JS 脚本时，V8 首先会创建一个全局上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。当在执行宏任务脚本时，产生的微任务都会推入到这个微任务队列中，<strong>也就是说每个宏任务都关联了一个微任务队列。</strong></p><h3 id="微任务产生的时机" tabindex="-1">微任务产生的时机 <a class="header-anchor" href="#微任务产生的时机" aria-label="Permalink to &quot;微任务产生的时机&quot;">​</a></h3><p>现代浏览器一般有两种产生微任务的时机</p><ol><li><p>MutationObserver：监控某个 DOM 节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 选择需要观察变动的节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> targetNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;some-id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 观察器的配置（需要观察什么变动）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { attributes: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, childList: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, subtree: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当观察到变动时执行的回调函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callback</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutationsList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">observer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Use traditional &#39;for loops&#39; for IE 11</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mutation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mutationsList) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (mutation.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;childList&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;A child node has been added or removed.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (mutation.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;attributes&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &#39;The &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mutation.attributeName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39; attribute was modified.&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个观察器实例并传入回调函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> observer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 以上述配置开始观察目标节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(targetNode, config);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 之后，可停止观察</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disconnect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><div class="warning custom-block"><p class="custom-block-title">监听 DOM 变化的历史</p><ol><li>一开始简单粗暴的使用轮询机制去检测 DOM 是否变动</li><li>2000 年的时候引入了 Mutation Event，Mutation Event 采用了观察者的设计模式。但是这属于同步回调，会在 DOM 变动时立即执行回调，会产生较大的性能开销</li><li>从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。使用微任务</li></ol></div></li><li><p>Promise API</p></li></ol><h3 id="微任务触发的时机" tabindex="-1">微任务触发的时机 <a class="header-anchor" href="#微任务触发的时机" aria-label="Permalink to &quot;微任务触发的时机&quot;">​</a></h3><p>当宏任务 JS 脚本将要执行完之前，JS 引擎准备退出全局执行上下文并清空调用栈的时候，JS 引擎会先检查全局上下文中的微任务队列，然后按照顺序执行微任务。</p><p><img src="`+t+'" alt="img" loading="lazy"></p><div class="warning custom-block"><p class="custom-block-title">严重注意</p><p>微任务是在 JS 引擎中创建的，所以执行时机是在退出 JS 脚本执行的时候，而不是在执行完宏任务之前。<strong>也就是说，微任务不一定会在当前宏任务结束之前执行</strong>，如下图：</p><p><img src="'+h+'" alt="image-20211123095728937" loading="lazy"></p><p>而且一个宏任务期间，可能会执行两次微任务队列。（虽然很少见，但是更加说明了微任务队列是 V8 引擎维护的）</p><p>例如在页面初始化 ParseHTML 阶段，放置两个 <code>script</code> 标签脚本时，就会出现下面情况</p><p><img src="'+k+'" alt="image-20211123100311378" loading="lazy"></p></div><h2 id="延迟队列-定时器的实现" tabindex="-1">延迟队列：定时器的实现 <a class="header-anchor" href="#延迟队列-定时器的实现" aria-label="Permalink to &quot;延迟队列：定时器的实现&quot;">​</a></h2><p>延迟队列维护了需要延迟执行的任务，包括了定时器和 Chromium 内部一些需要延迟执行的任务。</p><p>值得注意的是，这不是一个队列结构，而是一个 hashmap 结构。因为定时器有延迟时间，并不符合先进先出的结构</p><p>感觉不是很能理解，待续</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://time.geekbang.org/column/article/135624" target="_blank" rel="noreferrer">极客-宏任务和微任务：不是所有任务都是一个待遇</a></p><p><a href="https://whatwg-cn.github.io/html/#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" target="_blank" rel="noreferrer">WHATWG 规范</a></p>',39),E=[d];function o(c,g,b,y,m,u){return a(),i("div",null,E)}const _=s(r,[["render",o]]);export{D as __pageData,_ as default};
