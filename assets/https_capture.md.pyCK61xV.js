import{_ as e,c as o,o as a,aR as l,dk as t,dl as i,dm as r,dn as d,dp as c,dq as s,dr as n}from"./chunks/framework.DLAwTCsc.js";const H=JSON.parse('{"title":"抓包分析","description":"","frontmatter":{},"headers":[],"relativePath":"https/capture.md","filePath":"03_网络协议/02_https/04_抓包分析.md","lastUpdated":1739447932000}'),p={name:"https/capture.md"},h=l('<h1 id="抓包分析" tabindex="-1">抓包分析 <a class="header-anchor" href="#抓包分析" aria-label="Permalink to &quot;抓包分析&quot;">​</a></h1><p>可通过 <code>Wireshark</code> 工具打开<a href="https://github.com/tianya071128/wenshuli/blob/master/client/demo/%E6%8A%93%E5%8C%85/TCP%20%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B%E9%98%B6%E6%AE%B5.pcapng" target="_blank" rel="noreferrer">文件</a>查看</p><h2 id="tcp-握手阶段" tabindex="-1">TCP 握手阶段 <a class="header-anchor" href="#tcp-握手阶段" aria-label="Permalink to &quot;TCP 握手阶段&quot;">​</a></h2><p>HTTPS 的协议名是 <code>https</code>，而且默认端口号是 <code>443</code>，所以客户端请求时直接就知道是 <code>HTTPS</code> 协议，而不是像 <code>h2</code> 一样还存在协议升级的问题(<code>h2</code> 没有独立的协议名)</p><p><code>HTTPS</code> 是 <code>HTTP + SSL(TLS)</code> 协议组成的，传输数据先通过 <code>HTTP</code> 组成报文，将报文数据传递给 <code>SSL</code> 进行加密，再将加密的数据通过 <code>TCP</code> 进行传输，所以一开始跟 <code>HTTP</code> 相同，需要经过三次握手建立 TCP 连接</p><p><img src="'+t+'" alt="image-20220613150409148" loading="lazy"></p><h2 id="tls1-2-握手阶段" tabindex="-1">TLS1.2 握手阶段 <a class="header-anchor" href="#tls1-2-握手阶段" aria-label="Permalink to &quot;TLS1.2 握手阶段&quot;">​</a></h2><p>HTTPS 与 HTTP 最大的区别就是中间多了一个 TLS 协议，通过 TLS 协议建立一个安全通道进行数据传输。</p><ul><li>HTTPS 协议：HTTP 进行报文合成，交给 TLS 协议加密传输</li><li>HTTP 协议：直接与 TCP 进行数据传输</li></ul><p>基于此，在 TCP 握手之后，还需要<strong>在 TLS 协议层面进行握手，以实现验证服务端身份(数字证书)、交换得到密钥等功能</strong>。</p><p>TLS 握手阶段流程图<a href="/wzb_knowledge_base/https/tls.html#tls-1-2-的握手过程">可参照</a>，下图是抓包的整体握手图：</p><p><img src="'+i+'" alt="image-20220613171307383" loading="lazy"></p><h3 id="_1-客户端发送-client-hello-消息" tabindex="-1">1. 客户端发送 Client Hello 消息 <a class="header-anchor" href="#_1-客户端发送-client-hello-消息" aria-label="Permalink to &quot;1. 客户端发送 Client Hello 消息&quot;">​</a></h3><p><code>Client Hello</code> 消息主要告诉服务端以下数据：</p><ul><li>客户端的版本号：<code>Version: TLS 1.2 (0x0303)</code></li><li>支持的密码套件：<code>Cipher Suites(16 suites)</code></li><li>随机数，用于后续生成会话密钥：<code>Random: .......</code></li></ul><p><img src="'+r+'" alt="image-20220613152405330" loading="lazy"></p><h3 id="_2-服务端发送消息" tabindex="-1">2. 服务端发送消息 <a class="header-anchor" href="#_2-服务端发送消息" aria-label="Permalink to &quot;2. 服务端发送消息&quot;">​</a></h3><p>服务端收到客户端的 <code>Client Hello</code> 消息后，会回复如下消息，会作为一个整体回复(如果过大，可能会被 TCP 分包)，<strong>注意：因为证书数据大，所以这里分为两个包传输这些消息</strong></p><ul><li><p>服务端回复 <code>Server Hello</code> 消息，主要回复如下数据：</p><ul><li>服务端的版本号：<code>Version: TLS 1.2 (0x0303)</code></li><li>从客户端的列表里选一个作为本次通信使用的密码套件：<code>Cipher Suite: TLS_ECDHE_RSA_with_AES_128_GCM_SHA256 (0xc02f)</code></li><li>随机数：<code>Random: 15b473df771579e1e@46a9115887ce24a58d556d2b9a1593...</code></li></ul><p><img src="'+d+'" alt="image-20220613162256447" loading="lazy"></p></li><li><p>发送证书 <code>Certificate</code> 消息</p></li><li><p>发送 <code>Server Key Exchange</code> 消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。</p></li><li><p>最后发送 <code>Server Hello Done</code> 消息，表示消息发送完毕</p><p><img src="'+c+'" alt="image-20220613164436525" loading="lazy"></p></li></ul><h3 id="_3-客户端发送消息" tabindex="-1">3. 客户端发送消息 <a class="header-anchor" href="#_3-客户端发送消息" aria-label="Permalink to &quot;3. 客户端发送消息&quot;">​</a></h3><p>经过上面两步，客户端和服务器通过明文共享了三个信息：<code>Client Random</code>、<code>Server Random</code> 和 <code>Server Params</code>。</p><blockquote><ul><li><code>Client Random</code>：客户端发送 <code>Client Hello</code> 消息传递的</li><li><code>Server Random</code>：服务端发送 <code>Server Hello</code> 消息传递的</li><li><code>Server Params</code>：服务端发送 <code>Server Key Exchange</code> 消息传递的</li></ul></blockquote><ul><li>客户端拿到服务端的证书：走证书链逐级验证，确认证书的真实性，再用证书公钥验证签名，就确认了服务器的身份，<strong>这里客户端内部处理，不需要发送消息</strong></li><li>客户端发送 <code>Client Key Exchange</code>消息，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），<strong>注意：这个 Client Params 是用证书的公钥加密的，所以只有服务端才能进行解密</strong></li><li>客户端和服务端生成用于加密会话的主密钥，叫 <strong>“Master Secret”</strong>。 <ul><li>客户端和服务端使用 <code>Client Params</code>、<code>Server Params</code> 用 ECDHE 算法得出 <strong>Pre-Master</strong>，也是一个随机数</li><li>客户端和服务端现在存在三个随机数：<strong>Client Random、Server Random 和 Pre-Master</strong>。<strong>用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”</strong>。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥。</li></ul></li><li>客户端发送 <code>Change Cipher Spec</code> 消息，标识更改密码规范</li><li>客户端发送 <code>Finished</code> 消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。</li></ul><p><img src="'+s+'" alt="image-20220613170740473" loading="lazy"></p><h3 id="_4-服务端发送消息" tabindex="-1">4. 服务端发送消息 <a class="header-anchor" href="#_4-服务端发送消息" aria-label="Permalink to &quot;4. 服务端发送消息&quot;">​</a></h3><p>服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了。</p><p><strong>这里与极客课程有点不同，应该是协议些许变化的问题</strong></p><p><img src="'+n+'" alt="image-20220613171009205" loading="lazy"></p>',28),_=[h];function m(g,T,S,u,P,C){return a(),o("div",null,_)}const f=e(p,[["render",m]]);export{H as __pageData,f as default};
