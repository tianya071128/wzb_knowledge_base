import{_ as e,c as a,o,aR as t}from"./chunks/framework.DLAwTCsc.js";const _=JSON.parse('{"title":"请求方法","description":"","frontmatter":{},"headers":[],"relativePath":"http/method.md","filePath":"03_网络协议/01_http/02_请求方法.md","lastUpdated":1739447932000}'),l={name:"http/method.md"},i=t('<h1 id="请求方法" tabindex="-1">请求方法 <a class="header-anchor" href="#请求方法" aria-label="Permalink to &quot;请求方法&quot;">​</a></h1><p>请求方法就是<strong>客户端发出一个&quot;动作指令&quot;, 要求服务器对 URI 定位的资源执行这个动作</strong></p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>资源是存储在服务器上的, 服务器拥有绝对的决策权, 即使客户端发出了&quot;动作指令&quot;, 执不执行也是服务器决定的</p></div><p>HTTP/1.1 规定了八种方法, <strong>单词必须是大写形式</strong></p><ol><li>GET：获取资源，可以理解为读取或者下载数据；</li><li>HEAD：获取资源的元信息；</li><li>POST：向资源提交数据，相当于写入或上传数据；</li><li>PUT：类似 POST；</li><li>DELETE：删除资源；</li><li>CONNECT：建立特殊的连接隧道；</li><li>OPTIONS：列出可对资源实行的方法；</li><li>TRACE：追踪请求 - 响应的传输路径。</li></ol><p>常用的是 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 四种, 也就是 restful api 接口规范中定义的四种</p><h2 id="安全与幂等" tabindex="-1">安全与幂等 <a class="header-anchor" href="#安全与幂等" aria-label="Permalink to &quot;安全与幂等&quot;">​</a></h2><p>安全: 请求方法不会破坏服务器上的资源</p><p>幂等: 多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。</p><p>从请求方法的语义来看:</p><p>安全: 只有 <code>GET</code> 和 <code>HEAD</code> 是安全的</p><p>幂等:</p><ul><li><code>GET</code> 和 <code>HEAD</code> 是幂等的, 多次请求资源也是相同的</li><li><code>DELETE</code> 也是幂等的, 多次删除资源结果也是一样, 同一资源只会删除一次</li><li><code>POST</code> 不是幂等的, POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的</li><li><code>PUT</code> 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。</li></ul><h2 id="get-获取资源" tabindex="-1">GET: 获取资源 <a class="header-anchor" href="#get-获取资源" aria-label="Permalink to &quot;GET: 获取资源&quot;">​</a></h2><p>从服务器上获取指定资源, 这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。</p><ul><li><p>一般使用 GET 请求缓存资源, <strong>在 HTTP 规范, 并没有规定一定只有 get 请求才能缓存</strong></p></li><li><p>GET 请求一般通过 url 传参, 但是也可以实现 body 请求体传参</p><p>通过 postman 等工具是可以 body 传参的, 在 <code>ajax</code> 暂时没有发现方法</p></li></ul><h2 id="post-新建资源" tabindex="-1">POST: 新建资源 <a class="header-anchor" href="#post-新建资源" aria-label="Permalink to &quot;POST: 新建资源&quot;">​</a></h2><p>向资源提交数据，相当于写入或上传数据, 与 <code>PUT</code> 的语义很接近</p><ul><li><p>有一种说法是 <code>POST</code> 会至少分两个包发送, 可能是以前的实现, 目前是没有的</p><p>通过抓包测试, 并不会发送两个包, 只有 body 请求体过大, TCP 才会正常拆包</p></li></ul><h2 id="put-替换或更新资源" tabindex="-1">PUT: 替换或更新资源 <a class="header-anchor" href="#put-替换或更新资源" aria-label="Permalink to &quot;PUT: 替换或更新资源&quot;">​</a></h2><p>PUT 是修改, update 的含义, 而 POST 是新建, create 的含义</p><h2 id="delete-删除资源" tabindex="-1">DELETE: 删除资源 <a class="header-anchor" href="#delete-删除资源" aria-label="Permalink to &quot;DELETE: 删除资源&quot;">​</a></h2><p>一般而言, 服务器上的资源并不会真正意义上的删除, 而是增加一个删除的标记而已</p><h2 id="options-可对资源实行的方法-跨域预检机制" tabindex="-1">OPTIONS: 可对资源实行的方法, 跨域预检机制 <a class="header-anchor" href="#options-可对资源实行的方法-跨域预检机制" aria-label="Permalink to &quot;OPTIONS: 可对资源实行的方法, 跨域预检机制&quot;">​</a></h2><p>这个请求通常在出现跨域的时候, 当请求为跨域请求并且是 非简单类型请求(<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noreferrer">具体可见</a>) 时浏览器会自动发送</p><h2 id="其他方法" tabindex="-1">其他方法 <a class="header-anchor" href="#其他方法" aria-label="Permalink to &quot;其他方法&quot;">​</a></h2><ul><li><p>HEAD: 获取资源的元信息；</p><p>跟 <code>GET</code> 类似, 但是服务器不会返回请求的实体数据, 只会传回响应头, 用于给客户端这个资源的信息</p></li><li><p>CONNECT: 是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。</p></li><li><p>TRACE: 方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。</p></li><li><p>扩展方法: 可自行扩展方法, HTTP 有很强的扩展性, 只要请求-应答双方自行约定</p></li></ul><h2 id="资料" tabindex="-1">资料 <a class="header-anchor" href="#资料" aria-label="Permalink to &quot;资料&quot;">​</a></h2><ul><li><a href="https://www.zhihu.com/question/28586791/answer/767316172?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1039662417399181312&amp;utm_content=group3_Answer&amp;utm_campaign=shareopn" target="_blank" rel="noreferrer">GET 和 POST 的区别</a>: 分析的很到位</li></ul>',29),r=[i];function d(p,c,n,s,h,u){return o(),a("div",null,r)}const P=e(l,[["render",d]]);export{_ as __pageData,P as default};
