import{_ as e,c as o,o as a,aR as t,d1 as c,d2 as r,d3 as d,d4 as i,d5 as p,d6 as l,d7 as n}from"./chunks/framework.DLAwTCsc.js";const A=JSON.parse('{"title":"HTTP 抓包分析","description":"","frontmatter":{"title":"HTTP 抓包分析","date":"2021-10-21T15:00:00.000Z","permalink":"/http/capture","categories":["其他","HTTP"],"tags":[null]},"headers":[],"relativePath":"http/capture.md","filePath":"03_网络协议/01_http/10_抓包分析.md","lastUpdated":1739447932000}'),s={name:"http/capture.md"},h=t('<h1 id="抓包分析" tabindex="-1">抓包分析 <a class="header-anchor" href="#抓包分析" aria-label="Permalink to &quot;抓包分析&quot;">​</a></h1><p>基于 <code>Wireshark</code> 工具进行的抓包分析，使用 <code>PostWoman</code> 谷歌插件进行 <code>HTTP</code> 调试</p><h2 id="握手建立连接" tabindex="-1">握手建立连接 <a class="header-anchor" href="#握手建立连接" aria-label="Permalink to &quot;握手建立连接&quot;">​</a></h2><p>三次握手是 <code>TCP</code> 层面的，是 <code>TCP</code> 用来建立连接操作，可通过 <code>Wireshark</code> 工具打开<a href="https://github.com/tianya071128/wenshuli/blob/master/client/demo/%E6%8A%93%E5%8C%85/TCP%20%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B%E9%98%B6%E6%AE%B5.pcapng" target="_blank" rel="noreferrer">文件</a>查看</p><p><img src="'+c+'" alt="image-20220610111925586" loading="lazy"></p><ol><li><p>客户端发起建立连接：<code>63074 -&gt; 5000 [SYN] Seq=0 Win=8192 Len=0 MSS=65475 WS=256 SACK_PERM=1</code></p><p><strong>客户端(端口 <code>63074</code>) 向服务端(端口 <code>5000</code>) 发送一个 <code>[SYN]</code> 标识的消息，请求建立连接</strong></p></li><li><p>服务端响应客户端的连接：<code>5000 -&gt; 63074 [SYN, ACK] Seq=0 Ack=1 Win=8192 Len=@ MSS=65475 WS=256 SACK _PERM=1</code></p><p><strong>服务端发送 <code>[ACK]</code> 表示收到客户端请求的包，发送 <code>[SYN]</code> 标识表示同意建立连接，这两个会在一个包中发送出去</strong></p></li><li><p>客户端发送收到服务端包的消息：<code>63074 -&gt; 5000 [ACK] Seg=1 Ack=1 Win=8192 Len=0</code></p><p><strong>客户端发送一个 <code>[ACK]</code> 消息，表示收到服务端发送的包</strong>，此时已经建立了连接，可以进行收发消息</p></li></ol><h3 id="为什么是三次握手" tabindex="-1">为什么是三次握手？ <a class="header-anchor" href="#为什么是三次握手" aria-label="Permalink to &quot;为什么是三次握手？&quot;">​</a></h3><p>简单理解就是：<strong>三次是保证双方互相明确对方能收能发的最低值</strong>，<a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noreferrer">详情可参考</a></p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>这个说法挺有道理的：<code>三次握手这个说法不好，其实是双方各一次握手，各一次确认，其中一次握手和确认合并在一起</code></p></div><h2 id="挥手断开连接" tabindex="-1">挥手断开连接 <a class="header-anchor" href="#挥手断开连接" aria-label="Permalink to &quot;挥手断开连接&quot;">​</a></h2><p>四次挥手也是 <code>TCP</code> 层面的，可通过 <code>Wireshark</code> 工具打开<a href="https://github.com/tianya071128/wenshuli/blob/master/client/demo/%E6%8A%93%E5%8C%85/TCP%20%E6%8F%A1%E6%89%8B%E6%8C%A5%E6%89%8B%E9%98%B6%E6%AE%B5.pcapng" target="_blank" rel="noreferrer">文件</a>查看</p><p><img src="'+r+'" alt="image-20220610150605059" loading="lazy"></p><ol><li><p>服务端(<strong>也可能是客户端</strong>)发出断开连接：<code>5000 -&gt; 63074 [FIN, ACK] Seq=379 Ack=1037 Win=6912 Len=0</code></p><p>服务端(或客户端)发送 <code>[FIN]</code> 标识请求断开连接</p></li><li><p>客户端发送表示收到服务端包的消息：<code>63074 -&gt; 5000 [ACK] Seq=1037 Ack=380 Win=7680 Len=0</code></p><p>客户端发送 <code>[ACK]</code> 表示收到服务端的包。<strong>接下来客户端根据自身情况决定是否断开连接</strong></p></li><li><p>客户端发送断开连接：<code>63074 -&gt; 5000 [FIN, ACK] Seq=1037 Ack=380 Win=7680 Len=0</code></p><p>客户端也同意断开连接，此时发送 <code>[FIN]</code> 标识断开连接</p></li><li><p>服务端发送收到客户端包的消息：<code>5000 -&gt; 63074 [ACK] Seq=380 Ack=1038 Win=6912 Len=0</code></p><p>服务端发送 <code>[ACK]</code> 消息表示包已经收到。<strong>此时双方都同意断开连接，此时 TCP 连接将断开</strong></p></li></ol><h2 id="http-收发消息" tabindex="-1">HTTP 收发消息 <a class="header-anchor" href="#http-收发消息" aria-label="Permalink to &quot;HTTP 收发消息&quot;">​</a></h2><p>在建立了 TCP 连接后，HTTP 就可以进行收发消息。此时 HTTP 组成请求(响应)报文并通过 TCP 通道进行数据传输</p><h3 id="借助-tcp-传输数据" tabindex="-1">借助 TCP 传输数据 <a class="header-anchor" href="#借助-tcp-传输数据" aria-label="Permalink to &quot;借助 TCP 传输数据&quot;">​</a></h3><p>下图中 <code>HTTP</code> 是 <code>Connection: keep-alive</code> 持久连接的，所以会复用 <code>TCP</code> 连接</p><p><img src="'+d+'" alt="image-20220613085425225" loading="lazy"></p><ol><li>客户端发送 <code>GET</code> 请求：<code>GET /vuepress_test/http/cache HTTP/1.1</code></li><li>服务端发送 <code>[ACK]</code> 表示收到包：<code>5000 -&gt; 63074 [ACK] Seq=1 Ack=519 Win=7424 Len=0</code></li><li>服务端响应请求：<code>HTTP/1.1 200 OK (text/plain)</code></li><li>客户端发送 <code>[ACK]</code> 表示收到包：<code>63074 -&gt; 5000 [ACK] Seq=519 Ack=190 Win=7936 Len=0</code></li></ol><p>上述就是简单的 <code>GET</code> 请求过程，因为数据量比较小，一个 TCP 包就可以传输数据了</p><h3 id="http-超文本传输协议" tabindex="-1">HTTP 超文本传输协议？ <a class="header-anchor" href="#http-超文本传输协议" aria-label="Permalink to &quot;HTTP 超文本传输协议？&quot;">​</a></h3><p><code>HTTP</code> 是一个超文本传输协议，超的意思是不止可以传输文本，还可以传输<strong>图片、音频、视频等超文本</strong>。</p><p>那为什么是<strong>文本协议</strong>？如下图所示，<strong>HTTP 报文中请求和响应消息的头是以 <a href="https://baike.baidu.com/item/ASCII/309296" target="_blank" rel="noreferrer">ASCII</a> 编码方式，所以会被解析成可见字符</strong>。而消息内容则具有一个类似<a href="https://baike.baidu.com/item/MIME/2900607" target="_blank" rel="noreferrer">MIME</a>的格式。</p><p><img src="'+i+'" alt="image-20220613091029471" loading="lazy"></p><h3 id="keep-alive-长连接" tabindex="-1">keep-alive 长连接 <a class="header-anchor" href="#keep-alive-长连接" aria-label="Permalink to &quot;keep-alive 长连接&quot;">​</a></h3><p>当客户端和服务端都是 <code>Connection: keep-alive</code> 的话，在收发一次请求时，不会断开 TCP 连接，而是会保持连接，直到一定时间都没有请求通过就会请求断开。</p><p>对于 HTTP 的 <code>keep-alive</code> 而言，在 <code>Node</code> 中可以通过 <a href="http://nodejs.cn/api/http.html#serverkeepalivetimeout" target="_blank" rel="noreferrer">server.keepAliveTimeout</a> 设置 <code>keep-alive</code> 超时时间，如下图所示：</p><p><img src="'+p+'" alt="image-20220613095447442" loading="lazy"></p><div class="warning custom-block"><p class="custom-block-title">TCP 层面的 keepAlive</p><p>TCP 连接默认就是持久连接的，<code>HTTP</code> 的 <code>keep-alive</code> 只是控制 <code>HTTP</code> 层面，当 HTTP 需要断开连接时，就会通知 TCP 断开连接。</p><p>TCP 持久连接也有类似检测心跳的机制，会在一定时间中没有数据传输时断开 TCP 连接</p><p><a href="https://zhuanlan.zhihu.com/p/224595048" target="_blank" rel="noreferrer">具体可参考</a></p></div><h3 id="post-请求" tabindex="-1">post 请求 <a class="header-anchor" href="#post-请求" aria-label="Permalink to &quot;post 请求&quot;">​</a></h3><p>有一种说法是 post 会发送响应体会单独一个 TCP 包传输？可以抓包测试一下</p><p>如下图所示，POST 请求不会再没有超时 TCP 包大小限制的情况下分包传输：</p><p><img src="'+l+'" alt="image-20220613100234649" loading="lazy"></p><h3 id="当传输数据稍大时" tabindex="-1">当传输数据稍大时 <a class="header-anchor" href="#当传输数据稍大时" aria-label="Permalink to &quot;当传输数据稍大时&quot;">​</a></h3><p>当 <code>HTTP</code> 传输数据大小大于 <code>TCP</code> 分包大小时，<code>TCP</code> 就会进行分包传输：</p><p><img src="'+n+'" alt="image-20220613101058719" loading="lazy"></p>',36),T=[h];function g(m,P,_,k,C,u){return a(),o("div",null,T)}const f=e(s,[["render",g]]);export{A as __pageData,f as default};
