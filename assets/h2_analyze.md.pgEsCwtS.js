import{_ as a,c as e,o as t,aR as i,dv as r,dw as s,dx as l,dy as o,dz as n,dA as p,dB as h}from"./chunks/framework.DLAwTCsc.js";const f=JSON.parse('{"title":"HTTP/2 内核剖析","description":"","frontmatter":{},"headers":[],"relativePath":"h2/analyze.md","filePath":"03_网络协议/03_http2/02_h2内核剖析.md","lastUpdated":1739447932000}'),d={name:"h2/analyze.md"},T=i('<h1 id="http-2-内核剖析" tabindex="-1">HTTP/2 内核剖析 <a class="header-anchor" href="#http-2-内核剖析" aria-label="Permalink to &quot;HTTP/2 内核剖析&quot;">​</a></h1><h2 id="如何连接-http-2" tabindex="-1">如何连接 HTTP/2？ <a class="header-anchor" href="#如何连接-http-2" aria-label="Permalink to &quot;如何连接 HTTP/2？&quot;">​</a></h2><p>HTTP/2 并没有引入新的协议名，那么就需要客户端和服务端协商 HTTP 版本号问题。</p><p>HTTP/2 “事实上”是基于 TLS 的(目前浏览器几乎只支持 HTTPS 协议的 HTTP/2)，所以会在 TLS 握手阶段过程客户端和服务端就对 HTTP 版本进行协商</p><h3 id="tls-握手过程的-http-版本协商" tabindex="-1">TLS 握手过程的 HTTP 版本协商 <a class="header-anchor" href="#tls-握手过程的-http-版本协商" aria-label="Permalink to &quot;TLS 握手过程的 HTTP 版本协商&quot;">​</a></h3><p>以下是基于 TLSv1.2 版本的握手：</p><ol><li><p>客户端发送 “Client Hello”相关消息时，客户端会把支持的 HTTP 版本告诉服务器：</p><p><img src="'+r+'" alt="enter image description here" loading="lazy"></p></li><li><p>服务器回复 &quot;Server Hello&quot; 相关消息时，可以将自己支持的 HTTP 版本告诉客户端：</p><p><img src="'+s+'" alt="image-20220624154020138" loading="lazy"></p></li><li><p>客户端回复消息：</p><ul><li><p>如果服务器也支持多个 HTTP 版本，客户端就会选择一个版本进行通信。</p></li><li><p><strong>如果服务器选定了一个版本的话，客户端就不会进行选择</strong>，下图就是当服务器支持多个 HTTP 版本时，客户端回复内容</p><p><img src="'+l+'" alt="enter image description here" loading="lazy"></p></li></ul></li></ol><p><strong>总之，在这一步需要协商出客户端和服务端通信的 HTTP 版本</strong></p><h3 id="连接前言" tabindex="-1">连接前言 <a class="header-anchor" href="#连接前言" aria-label="Permalink to &quot;连接前言&quot;">​</a></h3><p>当在 TLS 确定了 HTTP 版本后，如果确定是使用 HTTP/2 时，那么<strong>客户端必须要发送一个“连接前言”（connection preface）</strong>，用来确认建立 HTTP/2 连接。</p><p>这个“连接前言”是标准的 HTTP/1 请求报文，使用纯文本的 ASCII 码格式，请求方法是特别注册的一个关键字“PRI”，全文只有 24 个字节：</p><div class="language-tex vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tex</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PRI * HTTP/2.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\r\\n\\r\\nSM\\r\\n\\r\\n</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>当服务器没有拒绝这个请求后，那么后续双方就会使用 HTPP/2 进行收发消息</p><p><img src="'+o+'" alt="image" loading="lazy"></p><h2 id="头部压缩" tabindex="-1">头部压缩 <a class="header-anchor" href="#头部压缩" aria-label="Permalink to &quot;头部压缩&quot;">​</a></h2><p>使用 <strong>“HPACK”</strong> 算法来压缩头部数据。</p><p>“HPACK”算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是 <strong>“字典”</strong>（这有点类似 brotli），压缩和解压缩就是查表和更新表的操作。</p><h3 id="废除起始行" tabindex="-1">废除起始行 <a class="header-anchor" href="#废除起始行" aria-label="Permalink to &quot;废除起始行&quot;">​</a></h3><p>为了方便管理和压缩，<strong>HTTP/2 废除了原有的起始行概念</strong>，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，并且给这些“不是头字段的头字段”起了个特别的名字——“伪头字段”（pseudo-header fields）。而起始行里的版本号和错误原因短语因为没什么大用，顺便也给废除了。</p><p>为了与“真头字段”区分开来，这些“伪头字段”会在名字前加一个“:”，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。</p><p><img src="'+n+'" alt="image" loading="lazy"></p><h3 id="静态表" tabindex="-1">静态表 <a class="header-anchor" href="#静态表" aria-label="Permalink to &quot;静态表&quot;">​</a></h3><p>通过废除起始行，这样全都是“Key-Value”形式的字段，于是 HTTP/2 就为一些最常用的头字段定义了一个只读的 <strong>“静态表”</strong>（Static Table）。</p><p>如下图所示，这样客户端和服务端只要查表就可以知道字段名和对应的值，比如数字“2”代表“GET”，数字“8”代表状态码 200。</p><p><img src="'+p+'" alt="image" loading="lazy"></p><h3 id="动态表" tabindex="-1">动态表 <a class="header-anchor" href="#动态表" aria-label="Permalink to &quot;动态表&quot;">​</a></h3><p>对于有些字段只有 Key 没有 Value(例如:user-agent 的 value 每个客户端的都不一样,只有连接后才知道具体值)，或者是自定义字段，这就要用到“动态表”（Dynamic Table），它添加在静态表后面，结构相同，但会在编码解码的时候<strong>随时更新</strong>。</p><p>例如：第一次发送请求时的“user-agent”字段长是一百多个字节，用哈夫曼压缩编码发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号“65”。那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。</p><p><img src="'+h+'" alt="image" loading="lazy"></p>',29),c=[T];function _(g,m,P,u,H,b){return t(),e("div",null,c)}const q=a(d,[["render",_]]);export{f as __pageData,q as default};
