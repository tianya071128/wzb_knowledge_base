import{_ as e,c as a,o as n,aR as s}from"./chunks/framework.DLAwTCsc.js";const b=JSON.parse('{"title":"内容协商","description":"","frontmatter":{},"headers":[],"relativePath":"http/content.md","filePath":"03_网络协议/01_http/04_内容协商.md","lastUpdated":1739447932000}'),t={name:"http/content.md"},p=s(`<h1 id="内容协商" tabindex="-1">内容协商 <a class="header-anchor" href="#内容协商" aria-label="Permalink to &quot;内容协商&quot;">​</a></h1><p>HTTP 借助 TCP/IP 完成传输, TCP/IP 只关注数据传输, 而 HTTP 还需要对实体数据进行定义.</p><p>主要对以下内容进行协商:</p><ul><li><p>数据类型协商实体数据的内容，使用的是 MIME type;</p><p>相关的头字段是 Accept 和 Content-Type；</p></li><li><p>数据编码协商实体数据的压缩方式;</p><p>相关的头字段是 Accept-Encoding 和 Content-Encoding；</p></li><li><p>语言类型协商实体数据的自然语言;</p><p>相关的头字段是 Accept-Language 和 Content-Language；</p></li><li><p>字符集协商实体数据的编码方式;</p><p>相关的头字段是 Accept-Charset 和 Content-Type；</p></li></ul><div class="warning custom-block"><p class="custom-block-title">注意</p><p>客户端通过 <code>Accept-</code> 头部字段来与服务器进行内容协商, 但最终决定权在于服务器;</p><p><code>Accept-</code> 头部字段可以用 <code>,</code> 顺序列出多个可能的选项, 用 <code>;q=</code> 参数表示选项权重</p></div><h2 id="数据类型协商" tabindex="-1">数据类型协商 <a class="header-anchor" href="#数据类型协商" aria-label="Permalink to &quot;数据类型协商&quot;">​</a></h2><p>MIME(Multipurpose Internet Mail Extensions): 多用途互联网邮件扩展, 早在 HTTP 之前就运用在电子邮件系统, HTTP 采用了一部分用来表示实体数据类型</p><p>MIME 将数据分为八大类, 以下是常用的几类:</p><ul><li>text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。</li><li>image：即图像文件，有 image/gif、image/jpeg、image/png 等。</li><li>audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。</li><li>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，<strong>如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。</strong></li></ul><p><code>Accept</code>: 客户端头部字段表示客户端需要接收的 MIME type;</p><p><code>Content-Type</code>: 服务端表示实际返回的 MIME type;</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 表示客户端能够理解的数据类型 -- 浏览器会根据不同 url 来设置不同的 Accept</span></span>
<span class="line"><span>// 例如 img 图片中的 url, 那么就会期望接收 image 类型</span></span>
<span class="line"><span>Accept: text/html,application/xhtml+xml,application/xml;q=0.9</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 服务器返回实体数据类型</span></span>
<span class="line"><span>Content-Type: text/html; charset=UTF-8</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="数据编码-压缩-协商" tabindex="-1">数据编码(压缩)协商 <a class="header-anchor" href="#数据编码-压缩-协商" aria-label="Permalink to &quot;数据编码(压缩)协商&quot;">​</a></h2><p>HTTP 有时为了节约带宽, 会对实体数据进行压缩, 此时就需要告诉客户端压缩方式, 以便客户端进行数据解压</p><p>Encoding type: 编码格式, 常见的如下三种:</p><ul><li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li><li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；</li><li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）。</li></ul><p><code>Accept-Encoding</code>: 客户端头部字段表示客户端支持的编码格式;</p><p><code>Content-Encoding</code>: 服务端表示实际返回编码格式;</p><div class="tip custom-block"><p class="custom-block-title">提示</p><div class="language-tex vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tex</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Accept-Encoding: gzip, deflate, br</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content-Encoding: gzip</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果返回了一个浏览器不支持的压缩文件, 浏览器就会判定这个接口失败</p><p>当浏览器发现是压缩文件, 会先进行解压再交给调用调用结果</p><p><strong>虽然说压缩文件会将文件大小缩小, 但是需要客户端解压文件, 具体性能是否提升需要根据实际情况</strong></p></div><h2 id="数据语言类型协商" tabindex="-1">数据语言类型协商 <a class="header-anchor" href="#数据语言类型协商" aria-label="Permalink to &quot;数据语言类型协商&quot;">​</a></h2><p>“语言类型”就是人类使用的自然语言，例如英语、汉语、日语等，而这些自然语言可能还有下属的地区性方言</p><p><code>Accept-Language</code>: 客户端头部字段表示客户端可理解的自然语言;</p><p><code>Content-Encoding</code>: 服务端表示实际返回编码格式;</p><h2 id="数据字符集类型协商" tabindex="-1">数据字符集类型协商 <a class="header-anchor" href="#数据字符集类型协商" aria-label="Permalink to &quot;数据字符集类型协商&quot;">​</a></h2><p><code>Accept-Charset</code>: 客户端头部字段表示客户端可理解的自然语言;</p><p><strong>响应头里却没有对应的 Content-Charset，而是在 Content-Type 字段的数据类型后面用“charset=xxx”来表示</strong></p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为使用的语言完全可以由字符集推断出来</p></div><h2 id="vary-字段-内容协商结果" tabindex="-1">Vary 字段: 内容协商结果 <a class="header-anchor" href="#vary-字段-内容协商结果" aria-label="Permalink to &quot;Vary 字段: 内容协商结果&quot;">​</a></h2><p>有的时候，服务器会在响应头里多加一个 Vary 字段，记录服务器在内容协商时参考的请求头字段，给出一点信息</p><div class="language-tex vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tex</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// 表示服务端在内容协商时参考的请求头字段</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vary: Accept-Encoding,User-Agent,Accept</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="客户端携带-body-请求体" tabindex="-1">客户端携带 body 请求体 <a class="header-anchor" href="#客户端携带-body-请求体" aria-label="Permalink to &quot;客户端携带 body 请求体&quot;">​</a></h2><p>当客户端携带 body 请求体(一般为 post 请求)时, 也可以通过</p><p><code>Content-Type</code> 表示请求体数据的类型和字符集</p><p><code>Content-Encoding</code> 表示数据的编码</p><p><code>Content-Encoding</code> 表示数据的语言类型</p><p><strong>内容协商是针对报文的实体数据, 对请求报文和响应报文都是通用的</strong></p>`,36),i=[p];function l(c,o,d,r,h,u){return n(),a("div",null,i)}const m=e(t,[["render",l]]);export{b as __pageData,m as default};
