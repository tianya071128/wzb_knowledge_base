import{_ as a,c as t,o as e,aR as r,ds as o,dt as T,du as p}from"./chunks/framework.DLAwTCsc.js";const _=JSON.parse('{"title":"HTTP/2","description":"","frontmatter":{},"headers":[],"relativePath":"h2/home.md","filePath":"03_网络协议/03_http2/01_h2.md","lastUpdated":1739447932000}'),h={name:"h2/home.md"},i=r('<h1 id="http-2" tabindex="-1">HTTP/2 <a class="header-anchor" href="#http-2" aria-label="Permalink to &quot;HTTP/2&quot;">​</a></h1><p>HTTPS 是用来解决安全方面的问题，<strong>HTTP2 是用来解决性能方面的问题</strong>。</p><p>Google 率先发明了 SPDY 协议，随后互联网标准化组织 IETF 以 SPDY 为基础，综合其他多方的意见，推出了 “HTTP/2”。</p><p>可通过 <code>Wireshark</code> 工具打开<a href="https://github.com/tianya071128/wenshuli/blob/master/client/demo/%E6%8A%93%E5%8C%85/HTTP2%20%E8%BF%9E%E6%8E%A5.pcapng" target="_blank" rel="noreferrer">文件</a>查看</p><h2 id="为什么不叫-http-2-0" tabindex="-1">为什么不叫 HTTP/2.0？ <a class="header-anchor" href="#为什么不叫-http-2-0" aria-label="Permalink to &quot;为什么不叫 HTTP/2.0？&quot;">​</a></h2><p>HTTP/2 工作组认为以前的“1.0”“1.1”造成了很多的混乱和误解，让人在实际的使用中难以区分差异，所以就决定 HTTP 协议不再使用小版本号（minor version），只使用大版本号（major version），从今往后 HTTP 协议不会出现 HTTP/2.0、2.1，只会有“HTTP/2”“HTTP/3”……</p><h2 id="兼容-http-1" tabindex="-1">兼容 HTTP/1 <a class="header-anchor" href="#兼容-http-1" aria-label="Permalink to &quot;兼容 HTTP/1&quot;">​</a></h2><p>HTTP/2 需要兼容 HTTP/1，否则就会破坏互联网上无数现有的资产，这方面 TLS 已经有了先例（为了兼容 TLS1.2 不得不进行“伪装”）。</p><p>为了保持功能上的兼容，所以 HTTP/2 把 HTTP 分解成了“语义”和“语法”两个部分：</p><ul><li><strong>“语义”层不做改动，与 HTTP/1 完全一致</strong>。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。</li><li>主要对 &quot;语法&quot; 层面进行改动，完全变更了 HTTP 报文的传输格式。</li></ul><div class="warning custom-block"><p class="custom-block-title">HTTP/2 并没有引入新的协议名</p><p>与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议。</p><p>让浏览器或者服务器去自动升级或降级协议，免去了选择的麻烦，让用户在上网的时候都意识不到协议的切换，实现平滑过渡。</p></div><h2 id="htpp-2-特性" tabindex="-1">HTPP/2 特性 <a class="header-anchor" href="#htpp-2-特性" aria-label="Permalink to &quot;HTPP/2 特性&quot;">​</a></h2><h3 id="头部压缩" tabindex="-1">头部压缩 <a class="header-anchor" href="#头部压缩" aria-label="Permalink to &quot;头部压缩&quot;">​</a></h3><p>HTTP/1 里可以用头字段 “Content-Encoding” 指定 Body 的编码方式，比如用 gzip 压缩来节约带宽，但报文的另一个组成部分——Header 却被无视了，没有针对它的优化手段。</p><p>由于报文 Header 一般会携带“User Agent”“Cookie”“Accept”“Server”等许多固定的头字段，并且请求响应报文里有很多字段值都是重复的。</p><p>所以 HTTP/2 使用头部压缩进行优化，专门开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。</p><h3 id="二进制格式" tabindex="-1">二进制格式 <a class="header-anchor" href="#二进制格式" aria-label="Permalink to &quot;二进制格式&quot;">​</a></h3><p>HTTP/1 使用纯文本形式的报文，而 HTTP/2 不再使用肉眼可见的 ASCII 码，而是向下层的 TCP/IP 协议“靠拢”，全面采用二进制格式。二进制里只有“0”和“1”，可以严格规定字段大小、顺序、标志位等格式，解析起来没有歧义，实现简单，而且体积小、速度快，做到“内部提效”。</p><p>把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。</p><p><img src="'+o+'" alt="image" loading="lazy"></p><h3 id="虚拟的-流" tabindex="-1">虚拟的“流” <a class="header-anchor" href="#虚拟的-流" aria-label="Permalink to &quot;虚拟的“流”&quot;">​</a></h3><p>消息的“碎片”到达目的地后应该怎么组装起来呢？</p><p>HTTP/2 为此定义了一个“流”（Stream）的概念，它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个<strong>唯一的流 ID</strong>。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。</p><p>因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。</p><p>在“流”的层面上看，消息是一些有序的“帧”序列，而在“连接”的层面上看，消息却是乱序收发的“帧”。<strong>多个请求 / 响应之间没有了顺序关系，不需要排队等待</strong>，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率。</p><p><img src="'+T+'" alt="image" loading="lazy"></p><div class="tip custom-block"><p class="custom-block-title">为什么&quot;流&quot;是虚拟的?</p><p>客户端将多个请求分成不同的流，然后每个流里面在切成一个个帧，发送的时候是按帧发送的。每个帧存着一个流 ID 来表示它属于的流。服务端收到请求的时候将帧按流 ID 进行拼接。从传输的角度来看流是不存在的，只是看到了一个个帧，所以说流是虚拟的。</p></div><h3 id="服务器推送" tabindex="-1">服务器推送 <a class="header-anchor" href="#服务器推送" aria-label="Permalink to &quot;服务器推送&quot;">​</a></h3><p>基于虚拟&quot;流&quot;，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。</p><h3 id="强化安全" tabindex="-1">强化安全 <a class="header-anchor" href="#强化安全" aria-label="Permalink to &quot;强化安全&quot;">​</a></h3><p>出于兼容的考虑，HTTP/2 延续了 HTTP/1 的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</p><p>但由于 HTTPS 已经是大势所趋，<strong>而且主流的浏览器 Chrome、Firefox 等都公开宣布只支持加密的 HTTP/2，所以“事实上”的 HTTP/2 是加密的</strong>。也就是说，互联网上通常所能见到的 HTTP/2 都是使用“https”协议名，跑在 TLS 上面。</p><p>为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。</p><p>在 HTTP/2 标准制定的时候（2015 年）已经发现了很多 SSL/TLS 的弱点，而新的 TLS1.3 还未发布，所以加密版本的 HTTP/2 在安全方面做了强化，要求下层的通信协议必须是 TLS1.2 以上，还要支持前向安全和 SNI，并且把几百个弱密码套件列入了“黑名单”，比如 DES、RC4、CBC、SHA-1 都不能在 HTTP/2 里使用，相当于底层用的是“TLS1.25”。</p><h2 id="http-2-的协议栈" tabindex="-1">HTTP/2 的协议栈 <a class="header-anchor" href="#http-2-的协议栈" aria-label="Permalink to &quot;HTTP/2 的协议栈&quot;">​</a></h2><p><img src="'+p+'" alt="image" loading="lazy"></p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://time.geekbang.org/column/article/112036?screen=full" target="_blank" rel="noreferrer">极客时间-时代之风（上）：HTTP/2 特性概览</a></p><p><a href="https://stackoverflow.com/questions/36500050/what-if-an-http-1-1-client-talk-to-an-http-2-only-server-and-what-if-an-http-2-c/36501371#36501371" target="_blank" rel="noreferrer">stackoverflow-TLS 连接确定 HTTP 版本</a></p>',39),l=[i];function n(s,P,c,d,H,u){return e(),t("div",null,l)}const g=a(h,[["render",n]]);export{_ as __pageData,g as default};
