import{_ as a,c as e,o as t,aR as r,bT as o,bU as l,bV as i}from"./chunks/framework.DLAwTCsc.js";const f=JSON.parse('{"title":"导航流程","description":"","frontmatter":{},"headers":[],"relativePath":"browser/navigation.md","filePath":"01_前端/04_浏览器/02_导航流程.md","lastUpdated":1739447932000}'),n={name:"browser/navigation.md"},h=r('<h1 id="导航流程" tabindex="-1">导航流程 <a class="header-anchor" href="#导航流程" aria-label="Permalink to &quot;导航流程&quot;">​</a></h1><p>从输入 URL 到页面展示完整流程示意图，其中，用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。：</p><p><img src="'+o+'" alt="img" loading="lazy"></p><h2 id="用户输入" tabindex="-1">用户输入 <a class="header-anchor" href="#用户输入" aria-label="Permalink to &quot;用户输入&quot;">​</a></h2><p>当用户在地址栏输入关键字时：</p><ul><li>如果是搜索内容，就会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</li><li>如果是一个 URL 地址，就会根据规则，合成为完整的 URL。</li></ul><p>得到需要导航的 URL 后，浏览器还给了当前页面一次执行 <code>beforeunload</code> 事件的机会，<code>beforeunload</code> 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面</p><p>当前页面没有监听 beforeunload 事件或者同意了继续后续流程，进入加载状态，<strong>需要等待提交文档阶段，页面内容才会被替换</strong>。那么浏览器便进入下图的状态：</p><p><img src="'+l+'" alt="image-20220516165906641" loading="lazy"></p><h2 id="开始导航" tabindex="-1">开始导航 <a class="header-anchor" href="#开始导航" aria-label="Permalink to &quot;开始导航&quot;">​</a></h2><p>获取到导航 URL 后，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，由网络进程请求资源</p><h2 id="url-请求过程" tabindex="-1">URL 请求过程 <a class="header-anchor" href="#url-请求过程" aria-label="Permalink to &quot;URL 请求过程&quot;">​</a></h2><p>网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程，网络请求过程见 [http 模块] (/http/)</p><h2 id="读取响应头信息" tabindex="-1">读取响应头信息 <a class="header-anchor" href="#读取响应头信息" aria-label="Permalink to &quot;读取响应头信息&quot;">​</a></h2><p>网络进程接收到响应行和响应头之后，就开始解析响应头的内容。<strong>因为需要根据响应头数据来控制浏览器的行为，所以先读取响应头数据</strong></p><h3 id="重定向" tabindex="-1">重定向 <a class="header-anchor" href="#重定向" aria-label="Permalink to &quot;重定向&quot;">​</a></h3><p>如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。</p><p>这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了，此时会通知浏览器进程重定向</p><h3 id="响应数据处理" tabindex="-1">响应数据处理 <a class="header-anchor" href="#响应数据处理" aria-label="Permalink to &quot;响应数据处理&quot;">​</a></h3><p>根据 <code>Content-Type</code> 响应字段，可以知道服务器返回的响应体数据是什么类型，浏览器根据响应数据类型来决定如何显示响应体的内容</p><ul><li>如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束</li><li>如果是 <code>application/pdf</code>，那么就会通过 <code>pdf</code> 处理程序处理 <code>pdf</code></li><li>如果是 HTML，那么浏览器则会继续进行导航流程，<strong>此时页面渲染需要渲染进程，所以接下来就准备渲染进程了</strong></li></ul><h2 id="准备渲染进程" tabindex="-1">准备渲染进程 <a class="header-anchor" href="#准备渲染进程" aria-label="Permalink to &quot;准备渲染进程&quot;">​</a></h2><p>当处理资源需要渲染页面时，Chrome 默认会为每个页面分配一个渲染进程。但有一些特殊情况下，如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</p><p><strong>渲染进程准备好后，此时文档数据还在网络进程中，并没有提交给渲染进程</strong>，所以下一步就进入了提交文档阶段。</p><h2 id="提交文档" tabindex="-1">提交文档 <a class="header-anchor" href="#提交文档" aria-label="Permalink to &quot;提交文档&quot;">​</a></h2><p>提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</p><ul><li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li><li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li><li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li><li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li></ul><p>当<strong>渲染进程确认提交</strong>之后，更新内容如下图所示(这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面)：</p><p><img src="'+i+'" alt="image-20220517092455987" loading="lazy"></p><h2 id="导航流程结束" tabindex="-1">导航流程结束 <a class="header-anchor" href="#导航流程结束" aria-label="Permalink to &quot;导航流程结束&quot;">​</a></h2><p>至此，<strong>一个完整的导航流程就“走”完了</strong>，这之后就要进入渲染阶段了。一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p><p>渲染阶段见下一章节</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://time.geekbang.org/column/article/117637" target="_blank" rel="noreferrer">极客-导航流程</a></p><p><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="noreferrer">git-当···时发生了什么？</a></p>',35),s=[h];function p(d,c,_,u,b,m){return t(),e("div",null,s)}const q=a(n,[["render",p]]);export{f as __pageData,q as default};
