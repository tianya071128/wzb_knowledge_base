import type { Data } from '../component'
import type { RawSlots, Slots } from '../componentSlots'
import {
  type ContextualRenderFn,
  currentRenderingInstance,
} from '../componentRenderContext'
import {
  Comment,
  Fragment,
  type VNode,
  type VNodeArrayChildren,
  createBlock,
  createVNode,
  isVNode,
  openBlock,
} from '../vnode'
import { PatchFlags, SlotFlags, isSymbol } from '@vue/shared'
import { warn } from '../warning'
import { isAsyncWrapper } from '../apiAsyncComponent'

/**
 * Compiler runtime helper for rendering `<slot/>` 用于渲染`<slot/>`的编译器运行时助手
 * @private
 */
/**
 * Vue3 核心公共函数 - 插槽渲染的**唯一入口**，负责将标准化后的插槽函数转换为可渲染的VNode
 * 核心使命：
 *    1. 区分渲染模式：自定义元素模式（ce）渲染原生<slot>标签，普通Vue组件模式渲染插槽内容；
 *    2. 处理插槽调用：执行目标插槽函数并传入作用域props，保证作用域插槽参数正常传递；
 *    3. 兜底内容渲染：插槽不存在/无有效内容时，渲染编译器生成的fallback兜底内容；
 *    4. 块级渲染优化：通过openBlock/createBlock开启块跟踪，结合PatchFlags做精细化更新；
 *    5. 编译插槽兼容：处理编译插槽的_c/_d标记，临时启用块跟踪保证渲染逻辑正确；
 *    6. 开发环境校验：检测SSR优化插槽在非SSR环境的非法使用，抛出警告并兜底；
 *    7. 唯一key生成：为插槽Fragment生成唯一key，区分实际内容和兜底内容，避免diff混乱；
 *    8. 样式隔离保障：结合scopeId设置slotScopeIds，保证插槽内的作用域样式正常生效；
 *    9. 补丁标记智能设置：根据插槽稳定性（SlotFlags）设置PatchFlags，实现静态插槽复用、动态插槽全量更新；
 * 核心关联：被Vue模板编译器、手写渲染函数调用，是标准化插槽（normalizeSlot/normalizeObjectSlots处理后）
 *            转换为实际DOM的最后一步，衔接插槽标准化和虚拟DOM渲染。
 *
 *
 * @param {Slots} slots 组件内部标准化后的插槽对象（normalizeObjectSlots处理后，所有插槽均为函数）
 * @param {string} name 要渲染的插槽名（如default/title/menu，核心匹配标识）
 * @param {Data} props 传递给插槽的作用域参数（作用域插槽用，默认空对象）
 * @param {() => VNodeArrayChildren} [fallback] 插槽兜底内容生成函数，由编译器保证返回VNode数组，插槽无内容时渲染
 * @param {boolean} [noSlotted] 是否禁用插槽作用域样式标识，避免生成slotScopeIds，默认false
 * @returns {VNode} 插槽对应的Fragment类型VNode，可直接参与虚拟DOM的渲染和diff更新
 */
export function renderSlot(
  slots: Slots,
  name: string,
  props: Data = {},
  // this is not a user-facing function, so the fallback is always generated by 这不是面向用户的函数，因此后备始终由
  // the compiler and guaranteed to be a function returning an array 编译器并保证是一个返回数组的函数
  fallback?: () => VNodeArrayChildren,
  noSlotted?: boolean,
): VNode {
  // 分支1：自定义元素模式（ce=true）→ 渲染原生HTML <slot>标签，适配Web Components/自定义元素场景
  // 判定条件：当前渲染实例开启自定义元素模式，或父异步包装器实例开启自定义元素模式
  if (
    currentRenderingInstance!.ce ||
    (currentRenderingInstance!.parent &&
      isAsyncWrapper(currentRenderingInstance!.parent) &&
      currentRenderingInstance!.parent.ce)
  ) {
    // 判断是否有作用域参数需要传递给原生slot标签
    const hasProps = Object.keys(props).length > 0
    // in custom element mode, render <slot/> as actual slot outlets 在自定义元素模式下，将 <slot/> 渲染为实际的插槽出口
    // wrap it with a fragment because in shadowRoot: false mode the slot 用片段包装它，因为在 ShadowRoot: false 模式下插槽
    // element gets replaced by injected content 元素被注入的内容替换
    // 原生slot标签通过name属性指定插槽名，默认插槽无需设置，非默认插槽追加name属性到props
    if (name !== 'default') props.name = name

    // 渲染原生slot标签，用Fragment包裹（解决shadowRoot: false时slot元素被替换导致的结构问题）
    return (
      openBlock(), // 开启块级渲染，启用Vue的块跟踪优化
      // 创建块级Fragment VNode（块节点用于Vue的更新优化）
      createBlock(
        Fragment, // 根节点为Fragment，不生成实际DOM
        null,
        [createVNode('slot', props, fallback && fallback())], // 子节点为原生<slot>标签，传入props和兜底内容
        hasProps ? PatchFlags.BAIL : PatchFlags.STABLE_FRAGMENT,
      )
    )
  }

  // 分支2：普通Vue组件模式 → 渲染标准化插槽函数的执行结果
  // 获取指定名称的标准化插槽函数（不存在则为undefined）
  let slot = slots[name]

  // 开发环境专属：检测SSR优化的插槽函数在非SSR环境的非法使用
  if (__DEV__ && slot && slot.length > 1) {
    warn(
      `SSR-optimized slot function detected in a non-SSR-optimized render ` + // 在非SSR优化的渲染中检测到SSR优化的插槽函数
        `function. You need to mark this component with $dynamic-slots in the ` + // function。您需要在`
        `parent template.`, // 父模板
    )
    slot = () => []
  }

  // a compiled slot disables block tracking by default to avoid manual 编译槽默认禁用块跟踪以避免手动
  // invocation interfering with template-based block tracking, but in 调用会干扰基于模板的块跟踪，但在
  // `renderSlot` we can be sure that it's template-based so we can force `renderSlot` 我们可以确定它是基于模板的，所以我们可以强制
  // enable it. 启用它。

  // 处理编译插槽的块跟踪标记：编译插槽（_c=true）默认禁用块跟踪（_d=true）
  // 但在renderSlot中是模板化调用，可强制启用块跟踪（_d=false），避免手动调用干扰模板的块跟踪逻辑
  if (slot && (slot as ContextualRenderFn)._c) {
    ;(slot as ContextualRenderFn)._d = false
  }

  // 开启块级渲染，为后续createBlock做准备，启用Vue的块级diff优化
  openBlock()
  // 执行插槽函数并传入作用域props，通过ensureValidVNode保证返回合法的VNode/VNode数组（过滤无效值如null/布尔）
  const validSlotContent = slot && ensureValidVNode(slot(props))
  // 生成插槽的唯一key，优先级：props.key > 插槽内容自身的key（createSlots附加的分支key）
  const slotKey =
    props.key ||
    // slot content array of a dynamic conditional slot may have a branch 动态条件槽的槽内容数组可以有分支
    // key attached in the `createSlots` helper, respect that 附加在“createSlots”帮助器中的密钥，请尊重该密钥
    (validSlotContent && (validSlotContent as any).key)
  // 创建块级Fragment VNode，作为插槽内容的根容器（插槽允许多根节点，Fragment无实际DOM）
  const rendered = createBlock(
    Fragment,
    // Fragment的props：唯一key，保证diff时能正确识别插槽内容的变化
    {
      key:
        (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) +
        // #7256 force differentiate fallback content from actual content
        (!validSlotContent && fallback ? '_fb' : ''),
    },
    // 插槽实际渲染内容：有有效插槽内容则用，否则用兜底内容（无兜底则为空数组）
    validSlotContent || (fallback ? fallback() : []),
    // 智能设置补丁标记：静态插槽（STABLE）用STABLE_FRAGMENT复用，否则BAIL强制全量更新
    validSlotContent && (slots as RawSlots)._ === SlotFlags.STABLE
      ? PatchFlags.STABLE_FRAGMENT
      : PatchFlags.BAIL,
  )

  // 处理作用域样式：未禁用noSlotted且渲染节点有scopeId时，添加插槽专属作用域样式标识
  // 保证插槽内的DOM元素能正确匹配组件的作用域样式（如xxx-slot）
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + '-s']
  }

  // 恢复编译插槽的块跟踪标记：插槽渲染完成后，将_d置回true，恢复默认的块跟踪禁用状态
  if (slot && (slot as ContextualRenderFn)._c) {
    ;(slot as ContextualRenderFn)._d = true
  }

  // 返回插槽对应的块级Fragment VNode，参与后续的虚拟DOM渲染和diff
  return rendered
}

export function ensureValidVNode(
  vnodes: VNodeArrayChildren,
): VNodeArrayChildren | null {
  return vnodes.some(child => {
    if (!isVNode(child)) return true
    if (child.type === Comment) return false
    if (
      child.type === Fragment &&
      !ensureValidVNode(child.children as VNodeArrayChildren)
    )
      return false
    return true
  })
    ? vnodes
    : null
}
